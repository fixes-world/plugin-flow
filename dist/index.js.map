{"version":3,"sources":["environment.ts","checker.ts","formater.ts","baseAction.ts","wallet.service.ts","pure.signer.ts","flow.connector.ts","exception.ts","flow.wallet.ts","cache.ts","connector.ts","symbols.ts","../flow.json","wallet.ts","queries.ts","../src/assets/cadence/scripts/evm/call.cdc","../src/assets/cadence/scripts/evm/erc20/balance_of.cdc","../src/assets/cadence/scripts/evm/erc20/get_decimals.cdc","../src/assets/cadence/scripts/evm/erc20/total_supply.cdc","../src/assets/cadence/scripts/main-account/get_acct_info.cdc","script.defs.ts","di.ts","../src/assets/cadence/transactions/evm/call.cdc","../src/assets/cadence/transactions/main-account/account/create_new_account_with_coa.cdc","../src/assets/cadence/transactions/main-account/account/setup_coa.cdc","../src/assets/cadence/transactions/main-account/evm/transfer_erc20.cdc","../src/assets/cadence/transactions/main-account/flow-token/dynamic_vm_transfer.cdc","../src/assets/cadence/transactions/main-account/ft/generic_transfer_with_address.cdc","transaction.defs.ts","index.ts","transfer.ts","index.ts"],"sourcesContent":["import type { IAgentRuntime } from \"@elizaos/core\";\nimport { z } from \"zod\";\n\nconst FLOW_MAINNET_PUBLIC_RPC = \"https://mainnet.onflow.org\";\n\nexport const flowEnvSchema = z.object({\n    FLOW_ADDRESS: z\n        .string()\n        .min(1, \"Flow native address is required\")\n        .startsWith(\"0x\", \"Flow address must start with 0x\"),\n    FLOW_PRIVATE_KEY: z\n        .string()\n        .min(1, \"Flow private key for the address is required\")\n        .startsWith(\"0x\", \"Flow private key must start with 0x\"),\n    FLOW_NETWORK: z.string().optional().default(\"mainnet\"),\n    FLOW_ENDPOINT_URL: z.string().optional().default(FLOW_MAINNET_PUBLIC_RPC),\n});\n\nexport type FlowConfig = z.infer<typeof flowEnvSchema>;\n\nexport async function validateFlowConfig(\n    runtime: IAgentRuntime\n): Promise<FlowConfig> {\n    try {\n        const config = {\n            FLOW_ADDRESS:\n                runtime.getSetting(\"FLOW_ADDRESS\") || process.env.FLOW_ADDRESS,\n            FLOW_PRIVATE_KEY:\n                runtime.getSetting(\"FLOW_PRIVATE_KEY\") ||\n                process.env.FLOW_PRIVATE_KEY,\n            FLOW_NETWORK:\n                runtime.getSetting(\"FLOW_NETWORK\") ||\n                process.env.FLOW_NETWORK ||\n                \"mainnet\",\n            FLOW_ENDPOINT_URL:\n                runtime.getSetting(\"FLOW_ENDPOINT_URL\") ||\n                process.env.FLOW_ENDPOINT_URL ||\n                FLOW_MAINNET_PUBLIC_RPC,\n        };\n\n        return flowEnvSchema.parse(config);\n    } catch (error) {\n        if (error instanceof z.ZodError) {\n            const errorMessages = error.errors\n                .map((err) => `${err.path.join(\".\")}: ${err.message}`)\n                .join(\"\\n\");\n            throw new Error(\n                `Flow Blockchain configuration validation failed:\\n${errorMessages}`\n            );\n        }\n        throw error;\n    }\n}\n","import type { ScriptQueryResponse } from \"../types\";\n\n/**\n * Check if a string is a valid UUID\n * @param str The string to check\n * @returns true if the string is a valid UUID\n */\nexport function isUUID(str: string): boolean {\n    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n    return uuidRegex.test(str);\n}\n\n/**\n * Check if an address is a Flow address\n * @param address Address to check\n */\nexport function isFlowAddress(address: string) {\n    const regExp = /^0x[a-fA-F0-9]{16}$/gi;\n    return regExp.test(address);\n}\n\n/**\n * Check if an address is an EVM address\n * @param address Address to check\n */\nexport function isEVMAddress(address: string) {\n    const regExp = /^0x[a-fA-F0-9]{40}$/gi;\n    return regExp.test(address);\n}\n\n/**\n * Check if a string is a Cadence identifier\n * @param str String to check\n */\nexport function isCadenceIdentifier(str: string) {\n    const cadenceIdentifier = /^A\\.[0-9a-fA-F]{16}\\.[0-9a-zA-Z_]+/;\n    return cadenceIdentifier.test(str);\n}\n\n/**\n * Check if a string is a Cadence address\n * @param res\n */\nexport function isScriptQueryResponse(res: unknown): res is ScriptQueryResponse {\n    return res && typeof res === \"object\" && \"ok\" in res && typeof res.ok === \"boolean\";\n}\n","import type { Character } from \"@elizaos/core\";\nimport type { FlowAccountBalanceInfo } from \"../types\";\n\n/**\n * Format the agent wallet information\n * @param character\n * @param info\n */\nexport function formatAgentWalletInfo(character: Character, info: FlowAccountBalanceInfo): string {\n    let output = `Here is the Agent<${character.name}>'s Flow wallet information:\\n`;\n    output += formatWalletBalances(info);\n    return output;\n}\n\n/**\n * Format the account information\n * @param userId user id\n * @param accountName account name\n * @param info flow account information\n * @returns the formatted string\n */\nexport function formatWalletInfo(\n    userId: string,\n    accountName: string,\n    info: FlowAccountBalanceInfo = undefined,\n): string {\n    let output = formatAccountInfoPrefix(userId, accountName);\n    if (info === undefined) {\n        output += `- No wallet information found, maybe you don't have a wallet yet.`;\n    } else {\n        output += formatWalletBalances(info);\n    }\n    return output;\n}\n\n/**\n * Format the wallet balances\n * @param info\n * @returns\n */\nexport function formatWalletBalances(info: FlowAccountBalanceInfo): string {\n    let output = `- Flow wallet address: ${info.address}\\n`;\n    output += `- FLOW balance: ${info.balance} FLOW\\n`;\n    output += `- Flow wallet's COA(EVM) address: ${info.coaAddress || \"unknown\"}\\n`;\n    output += `- FLOW balance in COA(EVM) address: ${info.coaBalance ?? 0} FLOW`;\n    return output;\n}\n\n/**\n * Format the wallet created message\n * @param userId user id\n * @param accountName account name\n * @param newAddress new address\n * @returns the formatted string\n */\nexport function formatWalletCreated(\n    userId: string,\n    accountName: string,\n    newAddress: string,\n): string {\n    let output = formatAccountInfoPrefix(userId, accountName);\n    output += `- New created address: ${newAddress}`;\n    return output;\n}\n\n/**\n * Format the account information prefix\n */\nfunction formatAccountInfoPrefix(userId: string, accountName: string): string {\n    let output = \"Here is current user's account information:\\n\";\n    output += `- UserId: ${userId}\\n`;\n    output += `- WalletId: ${accountName}\\n`;\n    return output;\n}\n\n/**\n * Format the transaction sent message\n * @param txid\n * @param extra\n */\nexport function formatTransationSent(txId: string, network: string, extra?: string): string {\n    const baseUrl = network === \"testnet\" ? \"https://testnet.flowscan.io\" : \"https://flowscan.io\";\n    const txURL = `${baseUrl}/tx/${txId}/events`;\n    return `Transaction Sent: <${txURL}>\\n${extra ?? \"\"}`;\n}\n\n/**\n * Format the FLOW spent message\n * @param fromAddress\n * @param spent\n * @param gasFee\n */\nexport function formatFlowSpent(\n    fromAddress: string,\n    spent: number,\n    agentAddr: string,\n    gasFee: number,\n): string {\n    let output = fromAddress ? `- FLOW spent from ${fromAddress}: ${spent} FLOW\\n` : \"\";\n    if (gasFee > 0) {\n        output += `- GasFee spent from Agent[${agentAddr}]: ${gasFee} FLOW`;\n    }\n    return output;\n}\n","import { inject, injectable, unmanaged } from \"inversify\";\nimport {\n    composeContext,\n    elizaLogger,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    type State,\n} from \"@elizaos/core\";\nimport { type ActionOptions, BaseInjectableAction } from \"@elizaos-plugins/plugin-di\";\nimport type { TransactionResponse } from \"../types\";\nimport { validateFlowConfig } from \"../environment\";\nimport { FlowWalletService } from \"../services\";\nimport { WalletProvider } from \"../providers\";\nimport { isScriptQueryResponse } from \".\";\n\n/**\n * Base abstract class for injectable actions\n */\n@injectable()\nexport abstract class BaseFlowInjectableAction<T> extends BaseInjectableAction<T> {\n    // -------- Injects --------\n\n    // Inject the Flow Eliza Provider\n    @inject(WalletProvider)\n    public walletElizaProvider: WalletProvider;\n    // Inject the Flow wallet serivce\n    @inject(FlowWalletService)\n    public walletSerivce: FlowWalletService;\n\n    /**\n     * Constructor for the base injectable action\n     */\n    constructor(@unmanaged() opts: ActionOptions<T>) {\n        super(opts);\n    }\n\n    // -------- Abstract methods to be implemented by the child class --------\n\n    /**\n     * Abstract method to execute the action\n     * @param content The content object\n     * @param callback The callback function to pass the result to Eliza runtime\n     */\n    abstract execute(\n        content: T | null,\n        runtime: IAgentRuntime,\n        message: Memory,\n        state?: State,\n        callback?: HandlerCallback,\n    ): Promise<unknown | null>;\n\n    // -------- Implemented methods for Eliza runtime --------\n\n    /**\n     * Default implementation of the validate method\n     * You can override this method to add custom validation logic\n     *\n     * @param runtime The runtime object from Eliza framework\n     * @param message The message object from Eliza framework\n     * @param state The state object from Eliza framework\n     * @returns The validation result\n     */\n    async validate(runtime: IAgentRuntime, _message: Memory, _state?: State): Promise<boolean> {\n        // Validate the Flow environment configuration\n        await validateFlowConfig(runtime);\n\n        // You need to ensure that the wallet is valid\n        try {\n            await this.walletSerivce.wallet.getWalletBalance();\n        } catch {\n            elizaLogger.error(\"Failed to sync account info\");\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Default implementation of the preparation of action context\n     * You can override this method to add custom logic\n     */\n    protected async prepareActionContext(\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n    ): Promise<string> {\n        // Initialize or update state\n        let currentState: State;\n        if (!state) {\n            currentState = (await runtime.composeState(message)) as State;\n        } else {\n            currentState = await runtime.updateRecentMessageState(state);\n        }\n\n        // Get wallet info for context, no state update\n        const walletInfo = await this.walletElizaProvider.get(runtime, message);\n        state.walletInfo = walletInfo;\n\n        // Compose context\n        return composeContext({ state: currentState, template: this.template });\n    }\n\n    /**\n     * Default Handler function type for processing messages\n     * You can override this method to add custom logic\n     *\n     * @param runtime The runtime object from Eliza framework\n     * @param message The message object from Eliza framework\n     * @param state The state object from Eliza framework\n     * @param options The options object from Eliza framework\n     * @param callback The callback function to pass the result to Eliza runtime\n     */\n    async handler(\n        runtime: IAgentRuntime,\n        message: Memory,\n        state?: State,\n        options?: Record<string, unknown>,\n        callback?: HandlerCallback,\n    ) {\n        const res = await super.handler(runtime, message, state, options, callback);\n        if (res) {\n            if (isScriptQueryResponse(res)) {\n                if (res.ok) {\n                    elizaLogger.log(\n                        \"Action executed with script query successfully with data: \",\n                        JSON.stringify(res.data),\n                    );\n                } else {\n                    elizaLogger.error(\n                        \"Action executed with script query failed: \",\n                        res.errorMessage ?? res.error ?? \"Unknown error\",\n                    );\n                }\n            } else {\n                const { signer, txid } = res as TransactionResponse;\n                elizaLogger.log(\n                    `Action executed with transaction: ${signer.address}[${signer.keyIndex}] - ${txid}`,\n                );\n            }\n        }\n    }\n}\n","import { injectable, inject } from \"inversify\";\nimport { elizaLogger, Service, type ServiceType, type IAgentRuntime } from \"@elizaos/core\";\nimport { globalContainer } from \"@elizaos-plugins/plugin-di\";\nimport * as fcl from \"@onflow/fcl\";\nimport type {\n    ArgumentFunction,\n    TransactionCallbacks,\n    TransactionSentResponse,\n    TransactionTrackingPayload,\n} from \"../types\";\nimport {\n    WalletProvider,\n    ConnectorProvider,\n    type FlowConnector,\n    type FlowWallet,\n} from \"../providers\";\nimport { queryAccountBalanceInfo } from \"../queries\";\n\n// Add SAMPLE to ServiceType enum in types.ts\ndeclare module \"@elizaos/core\" {\n    export enum ServiceType {\n        FLOW_WALLET = \"flow-wallet\",\n    }\n}\n\n/**\n * Wallet provider\n */\n@injectable()\nexport class FlowWalletService extends Service {\n    private static isInitialized = false;\n\n    private _runtime: IAgentRuntime | null = null;\n    private _connector: FlowConnector;\n    private _wallet: FlowWallet;\n    private _maxKeyIndex: number;\n\n    private readonly keysInUse = new Set<number>();\n    private readonly keysTrackingPayloads = new Map<number, TransactionTrackingPayload>();\n\n    constructor(\n        @inject(ConnectorProvider)\n        private readonly connectorProvider: ConnectorProvider,\n        @inject(WalletProvider)\n        private readonly walletProvider: WalletProvider,\n    ) {\n        super();\n    }\n\n    static get serviceType(): ServiceType {\n        return \"flow-wallet\" as ServiceType.FLOW_WALLET;\n    }\n\n    async initialize(runtime: IAgentRuntime): Promise<void> {\n        // Verify if the service is already initialized\n        if (FlowWalletService.isInitialized) {\n            return;\n        }\n\n        this._runtime = runtime;\n        this._wallet = await this.walletProvider.getInstance(runtime);\n        this._connector = await this.connectorProvider.getInstance(runtime);\n\n        // Set the account key index\n        const acctInfo = await this._connector.getAccount(this._wallet.address);\n        this._maxKeyIndex = acctInfo.keys.length;\n\n        FlowWalletService.isInitialized = true;\n    }\n\n    /**\n     * Whether the service is initialized or not.\n     */\n    get isInitialized() {\n        return FlowWalletService.isInitialized;\n    }\n\n    /**\n     * Get the Flow connector\n     */\n    get connector() {\n        return this._connector;\n    }\n\n    /**\n     * Get the wallet provider\n     */\n    get wallet() {\n        return this._wallet;\n    }\n\n    /**\n     * Get the wallet address\n     */\n    get address() {\n        return this._wallet.address;\n    }\n\n    /**\n     * Get maximum key index of the wallet\n     */\n    get maxKeyIndex() {\n        return this._maxKeyIndex;\n    }\n\n    /// ----- User methods -----\n\n    /**\n     * Execute a script with available account key index of the wallet\n     * @param code\n     * @param argsFunc\n     * @param defaultValue\n     * @returns\n     */\n    async executeScript<T>(code: string, argsFunc: ArgumentFunction, defaultValue: T): Promise<T> {\n        return await this._wallet.executeScript(code, argsFunc, defaultValue);\n    }\n\n    /**\n     * Send transction with available account key index of the wallet\n     * @param code\n     * @param argsFunc\n     * @returns\n     */\n    async sendTransaction(\n        code: string,\n        argsFunc: ArgumentFunction,\n        callbacks?: TransactionCallbacks,\n    ): Promise<TransactionSentResponse> {\n        const index = await this.acquireAndLockIndex();\n        if (index < 0) {\n            throw new Error(\"No available account key index to send transaction\");\n        }\n\n        // use availalbe index and default private key\n        try {\n            const txId = await this._wallet.sendTransaction(\n                code,\n                argsFunc,\n                this._wallet.buildAuthorization(index),\n            );\n            if (txId) {\n                // Start transaction tracking\n                await this.startTransactionTrackingSubstribe(index, txId, callbacks);\n            }\n            return { txId, index };\n        } catch (error) {\n            // Acknowledge and unlock the account key index\n            await this.ackAndUnlockIndex(index);\n            throw error;\n        }\n    }\n\n    /// ----- Methods for convenience -----\n\n    /**\n     * Get the wallet account info\n     */\n    async getWalletAccountInfo() {\n        return queryAccountBalanceInfo(this.wallet, this.address);\n    }\n\n    /// ----- Internal methods -----\n\n    /**\n     * Start the service\n     */\n    private async startTransactionTrackingSubstribe(\n        index: number,\n        txid: string,\n        callbacks?: TransactionCallbacks,\n    ) {\n        // Clear any existing interval\n        if (this.keysTrackingPayloads.has(index)) {\n            const payload = this.keysTrackingPayloads.get(index);\n            // unsubscribe\n            payload.unsubscribe();\n            // remove the tracking payload\n            this.keysTrackingPayloads.delete(index);\n            // Acknowledge and unlock the account key index\n            await this.ackAndUnlockIndex(index);\n        }\n        elizaLogger.info(`FlowWalletService: Starting transaction tracking task for txid: ${txid}`);\n\n        let isFinalizedSent = false;\n        const unsub = fcl.tx(txid).subscribe((res) => {\n            // update the status\n            callbacks?.onStatusUpdated?.(txid, res);\n\n            if (res.status >= 3) {\n                if (!isFinalizedSent) {\n                    // callback on finalized\n                    callbacks?.onFinalized?.(txid, res, res.errorMessage);\n                    isFinalizedSent = true;\n                    // Acknowledge and unlock the account key index\n                    this.ackAndUnlockIndex(index);\n                }\n\n                if (res.status >= 4) {\n                    // callback on sealed\n                    callbacks?.onSealed?.(txid, res, res.errorMessage);\n                    // unsubscribe\n                    unsub();\n                }\n            }\n        });\n\n        // set to the tracking payload\n        this.keysTrackingPayloads.set(index, {\n            txId: txid,\n            unsubscribe: unsub,\n        });\n    }\n\n    /**\n     * Acquire and lock an available account key index\n     * @returns\n     */\n    private async acquireAndLockIndex(): Promise<number> {\n        for (let i = 0; i < this._maxKeyIndex; i++) {\n            if (!this.keysInUse.has(i)) {\n                this.keysInUse.add(i);\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Acknowledge and unlock an account key index\n     * @param index\n     */\n    private async ackAndUnlockIndex(index: number) {\n        if (index >= 0 && index < this._maxKeyIndex && this.keysInUse.has(index)) {\n            this.keysInUse.delete(index);\n        }\n    }\n}\n\n// Register the provider with the global container\nglobalContainer.bind(FlowWalletService).toSelf().inSingletonScope();\n","import elliptic from \"elliptic\";\nimport { SHA3 } from \"sha3\";\n\nexport default class PureSigner {\n    /**\n     * Sign a message with a private key\n     */\n    static signWithKey(privateKeyHex: string, msg: string) {\n        const ec = new elliptic.ec(\"p256\");\n        const key = ec.keyFromPrivate(Buffer.from(privateKeyHex, \"hex\"));\n        const sig = key.sign(this._hashMsg(msg));\n        const n = 32;\n        const r = sig.r.toArrayLike(Buffer, \"be\", n);\n        const s = sig.s.toArrayLike(Buffer, \"be\", n);\n        return Buffer.concat([r.valueOf(), s.valueOf()]).toString(\"hex\");\n    }\n\n    /**\n     * Hash a message\n     */\n    private static _hashMsg(msg: string) {\n        const sha = new SHA3(256);\n        sha.update(Buffer.from(msg, \"hex\"));\n        return sha.digest();\n    }\n}\n","import * as fcl from \"@onflow/fcl\";\nimport type { Account, TransactionStatus } from \"@onflow/typedefs\";\nimport type { IFlowScriptExecutor } from \"../../types\";\nimport Exception from \"../../types/exception\";\n\nexport type NetworkType = \"mainnet\" | \"testnet\" | \"emulator\";\n\nlet isGloballyInited = false;\nlet globallyPromise = null;\n\nexport class FlowConnector implements IFlowScriptExecutor {\n    /**\n     * Initialize the Flow SDK\n     */\n    constructor(\n        private readonly flowJSON: object,\n        public readonly network: NetworkType = \"mainnet\",\n        private readonly defaultRpcEndpoint: string = undefined\n    ) {}\n\n    /**\n     * Get the RPC endpoint\n     */\n    get rpcEndpoint() {\n        switch (this.network) {\n            case \"mainnet\":\n                return this.defaultRpcEndpoint ?? \"https://mainnet.onflow.org\";\n            case \"testnet\":\n                return \"https://testnet.onflow.org\";\n            case \"emulator\":\n                return \"http://localhost:8888\";\n            default:\n                throw new Exception(\n                    50000,\n                    `Network type ${this.network} is not supported`\n                );\n        }\n    }\n\n    /**\n     * Initialize the Flow SDK\n     */\n    async onModuleInit() {\n        if (isGloballyInited) return;\n\n        const cfg = fcl.config();\n        // Required\n        await cfg.put(\"flow.network\", this.network);\n        // Set the maximum of gas limit\n        await cfg.put(\"fcl.limit\", 9999);\n        // Set the RPC endpoint\n        await cfg.put(\"accessNode.api\", this.rpcEndpoint);\n        // Load Flow JSON\n        await cfg.load({ flowJSON: this.flowJSON });\n\n        isGloballyInited = true;\n    }\n\n    /**\n     * Ensure the Flow SDK is initialized\n     */\n    private async ensureInited() {\n        if (isGloballyInited) return;\n        if (!globallyPromise) {\n            globallyPromise = this.onModuleInit();\n        }\n        return await globallyPromise;\n    }\n\n    /**\n     * Get account information\n     */\n    async getAccount(addr: string): Promise<Account> {\n        await this.ensureInited();\n        return await fcl.send([fcl.getAccount(addr)]).then(fcl.decode);\n    }\n\n    /**\n     * General method of sending transaction\n     */\n    async sendTransaction(\n        code: string,\n        args: fcl.ArgumentFunction,\n        mainAuthz?: fcl.FclAuthorization,\n        extraAuthz?: fcl.FclAuthorization[]\n    ) {\n        await this.ensureInited();\n        if (typeof mainAuthz !== \"undefined\") {\n            return await fcl.mutate({\n                cadence: code,\n                args: args,\n                proposer: mainAuthz,\n                payer: mainAuthz,\n                authorizations:\n                    (extraAuthz?.length ?? 0) === 0\n                        ? [mainAuthz]\n                        : [mainAuthz, ...extraAuthz],\n            });\n        }\n        return await fcl.mutate({\n            cadence: code,\n            args: args,\n        });\n    }\n\n    /**\n     * Get transaction status\n     */\n    async getTransactionStatus(\n        transactionId: string\n    ): Promise<TransactionStatus> {\n        await this.ensureInited();\n        return await fcl.tx(transactionId).onceExecuted();\n    }\n\n    /**\n     * Get chain id\n     */\n    async getChainId() {\n        await this.ensureInited();\n        return await fcl.getChainId();\n    }\n\n    /**\n     * Send transaction with single authorization\n     */\n    async onceTransactionSealed(\n        transactionId: string\n    ): Promise<TransactionStatus> {\n        await this.ensureInited();\n        return fcl.tx(transactionId).onceSealed();\n    }\n\n    /**\n     * Get block object\n     * @param blockId\n     */\n    async getBlockHeaderObject(\n        blockId: string\n    ): Promise<fcl.BlockHeaderObject> {\n        await this.ensureInited();\n        return await fcl\n\n            .send([fcl.getBlockHeader(), fcl.atBlockId(blockId)])\n            .then(fcl.decode);\n    }\n\n    /**\n     * Send script\n     */\n    async executeScript<T>(\n        code: string,\n        args: fcl.ArgumentFunction,\n        defaultValue: T\n    ): Promise<T> {\n        await this.ensureInited();\n        try {\n            const queryResult = await fcl.query({\n                cadence: code,\n                args,\n            });\n            return (queryResult as T) ?? defaultValue;\n        } catch (e) {\n            console.error(e);\n            return defaultValue;\n        }\n    }\n}\n\nexport default FlowConnector;\n","export default class Exception extends Error {\n    constructor(\n        readonly code: number,\n        message?: string,\n        options?: ErrorOptions\n    ) {\n        super(message, options);\n    }\n}\n","import { elizaLogger, type IAgentRuntime } from \"@elizaos/core\";\nimport NodeCache from \"node-cache\";\nimport * as fcl from \"@onflow/fcl\";\nimport type { CompositeSignature, Account } from \"@onflow/typedefs\";\nimport type { FlowConnector } from \"./flow.connector\";\nimport PureSigner from \"./pure.signer\";\nimport type { IFlowScriptExecutor, IFlowSigner } from \"../../types\";\nimport Exception from \"../../types/exception\";\n\n/**\n * Flow wallet Provider\n */\nexport class FlowWallet implements IFlowSigner, IFlowScriptExecutor {\n    runtime: IAgentRuntime;\n    private readonly privateKeyHex?: string;\n    public readonly address: string;\n    // Runtime data\n    private account: Account | null = null;\n    public maxKeyIndex = 0;\n\n    constructor(\n        runtime: IAgentRuntime,\n        private readonly connector: FlowConnector,\n        private readonly cache: NodeCache = new NodeCache({ stdTTL: 300 }), // Cache TTL set to 5 minutes\n    ) {\n        const signerAddr = runtime.getSetting(\"FLOW_ADDRESS\");\n        if (!signerAddr) {\n            elizaLogger.error(\"No signer address\");\n            throw new Exception(50200, \"No signer info\");\n        }\n        this.address = signerAddr;\n        this.runtime = runtime;\n\n        const privateKey = runtime.getSetting(\"FLOW_PRIVATE_KEY\");\n        if (!privateKey) {\n            elizaLogger.warn(`The default Flow wallet ${this.address} has no private key`);\n        } else {\n            this.privateKeyHex = privateKey.startsWith(\"0x\") ? privateKey.slice(2) : privateKey;\n        }\n    }\n\n    /**\n     * Get the network type\n     */\n    get network() {\n        return this.connector.network;\n    }\n\n    /**\n     * Send a transaction\n     * @param code Cadence code\n     * @param args Cadence arguments\n     */\n    async sendTransaction(code: string, args: fcl.ArgumentFunction, authz?: fcl.FclAuthorization) {\n        return await this.connector.sendTransaction(code, args, authz ?? this.buildAuthorization());\n    }\n\n    /**\n     * Execute a script\n     * @param code Cadence code\n     * @param args Cadence arguments\n     */\n    async executeScript<T>(code: string, args: fcl.ArgumentFunction, defaultValue: T): Promise<T> {\n        return await this.connector.executeScript(code, args, defaultValue);\n    }\n\n    /**\n     * Build authorization\n     */\n    buildAuthorization(accountIndex = 0, privateKey = this.privateKeyHex) {\n        if (this.account) {\n            if (accountIndex > this.maxKeyIndex) {\n                throw new Exception(50200, \"Invalid account index\");\n            }\n        }\n        const address = this.address;\n        if (!privateKey) {\n            throw new Exception(50200, \"No private key provided\");\n        }\n        return (account: Account): fcl.AuthZ => {\n            return {\n                ...account,\n                addr: fcl.sansPrefix(address),\n                keyId: Number(accountIndex),\n                signingFunction: (signable: fcl.SigningData): Promise<CompositeSignature> => {\n                    return Promise.resolve({\n                        f_type: \"CompositeSignature\",\n                        f_vsn: \"1.0.0\",\n                        addr: fcl.withPrefix(address),\n                        keyId: Number(accountIndex),\n                        signature: this.signMessage(signable.message, privateKey),\n                    });\n                },\n            };\n        };\n    }\n\n    /**\n     * Sign a message\n     * @param message Message to sign\n     */\n    signMessage(message: string, privateKey = this.privateKeyHex) {\n        return PureSigner.signWithKey(privateKey, message);\n    }\n\n    // -----  methods -----\n\n    /**\n     * Sync account info\n     */\n    async syncAccountInfo() {\n        this.account = await this.connector.getAccount(this.address);\n        this.maxKeyIndex = this.account.keys.length - 1;\n        this.cache.set(\"balance\", this.account.balance / 1e8);\n        elizaLogger.debug(\"Flow account info synced\", {\n            address: this.address,\n            balance: this.account.balance,\n            maxKeyIndex: this.maxKeyIndex,\n            keyAmount: this.account.keys.length,\n        });\n    }\n\n    /**\n     * Get the wallet balance\n     * @returns Wallet balance\n     */\n    async getWalletBalance(forceRefresh = false): Promise<number> {\n        const cachedBalance = await this.cache.get<number>(\"balance\");\n        if (!forceRefresh && cachedBalance) {\n            return cachedBalance;\n        }\n        await this.syncAccountInfo();\n        return this.account ? this.account.balance / 1e8 : 0;\n    }\n}\n","import path from \"node:path\";\nimport { injectable } from \"inversify\";\nimport { v4 } from \"uuid\";\nimport type { IAgentRuntime, ICacheManager, Memory, Provider, State } from \"@elizaos/core\";\nimport NodeCache from \"node-cache\";\nimport { globalContainer, type InjectableProvider } from \"@elizaos-plugins/plugin-di\";\n\n/**\n * Cache provider\n */\n@injectable()\nexport class CacheProvider implements Provider, InjectableProvider<ICacheManager> {\n    private readonly _nodeCache: NodeCache;\n    private readonly cacheKey: string = \"eliza-flow/shared-cache\";\n    private readonly CACHE_EXPIRY_SEC = 120; // Cache TTL set to 2 minutes\n    private readonly providerId: string;\n    private _fileCache: ICacheManager;\n\n    /**\n     * Initialize the Flow connector provider\n     * @param flowJSON The Flow JSON object\n     */\n    constructor() {\n        this._nodeCache = new NodeCache({ stdTTL: this.CACHE_EXPIRY_SEC });\n        this.providerId = v4();\n    }\n\n    /**\n     * Get the cache manager instance\n     * @param runtime The runtime object from Eliza framework\n     */\n    async getInstance(runtime: IAgentRuntime): Promise<ICacheManager> {\n        if (!this._fileCache) {\n            this._fileCache = runtime.cacheManager;\n        }\n        return this._fileCache;\n    }\n\n    /**\n     * Eliza provider `get` method\n     * @returns The message to be injected into the context\n     */\n    async get(runtime: IAgentRuntime, _message: Memory, _state?: State): Promise<string | null> {\n        // ensure the cache manager is initialized\n        await this.getInstance(runtime);\n        return null;\n    }\n\n    /**\n     * Get cached data\n     */\n    public async getCachedData<T>(key: string): Promise<T | null> {\n        // Check in-memory cache first\n        const cachedData = this._nodeCache.get<T>(key);\n        if (cachedData) {\n            return cachedData;\n        }\n\n        // Check file-based cache\n        const fileCachedData = await this._readFromCache<T>(key);\n        if (fileCachedData) {\n            // Populate in-memory cache\n            this._nodeCache.set(key, fileCachedData);\n            return fileCachedData;\n        }\n\n        return null;\n    }\n\n    /**\n     * Set cached data in file-based cache\n     * @param cacheKey The cache key\n     * @param data The data to cache\n     * @param ttl The time-to-live in seconds, defaults to 120 seconds, if not provided\n     */\n    public async setCachedData<T>(cacheKey: string, data: T, ttl?: number): Promise<void> {\n        // Set in-memory cache\n        this._nodeCache.set(cacheKey, data);\n\n        // Write to file-based cache\n        await this._writeToCache(cacheKey, data, ttl);\n    }\n\n    // ---- Internal methods ----\n\n    private _getFileCacheKey(key: string) {\n        return path.join(this.cacheKey, this.providerId, key);\n    }\n\n    private async _readFromCache<T>(key: string): Promise<T | null> {\n        if (!this._fileCache) {\n            return null;\n        }\n        return await this._fileCache.get<T>(this._getFileCacheKey(key));\n    }\n\n    private async _writeToCache<T>(key: string, data: T, ttl?: number): Promise<void> {\n        await this._fileCache?.set(this._getFileCacheKey(key), data, {\n            expires: Date.now() + (ttl ?? this.CACHE_EXPIRY_SEC) * 1000,\n        });\n    }\n}\n\n// Cache provider is bound to request scope\nglobalContainer.bind<CacheProvider>(CacheProvider).toSelf().inRequestScope();\n\n// Export an extra cache provider instance without using inversify\nexport const cacheProvider = new CacheProvider();\n","import { injectable, inject } from \"inversify\";\nimport {\n    elizaLogger,\n    type IAgentRuntime,\n    type Memory,\n    type Provider,\n    type State,\n} from \"@elizaos/core\";\nimport { globalContainer, type InjectableProvider } from \"@elizaos-plugins/plugin-di\";\nimport { CONSTANTS } from \"../symbols\";\nimport FlowConnector, { type NetworkType } from \"./utils/flow.connector\";\n\n// Here is the configuration file for fixes.\nimport flowJSON from \"../../flow.json\" assert { type: \"json\" };\n\n/**\n * Create a new instance of the Flow connector\n * @param runtime\n * @param flowJSON\n */\nasync function _createFlowConnector(\n    runtime: IAgentRuntime,\n    flowJSON: object,\n): Promise<FlowConnector> {\n    const rpcEndpoint = runtime.getSetting(\"FLOW_ENDPOINT_URL\");\n    const network = runtime.getSetting(\"FLOW_NETWORK\") as NetworkType;\n    const instance = new FlowConnector(flowJSON, network, rpcEndpoint);\n    await instance.onModuleInit();\n    return instance;\n}\n\n/**\n * Get the singleton instance of the Flow connector\n * @param runtime\n */\nasync function getFlowConnectorInstance(\n    runtime: IAgentRuntime,\n    inputedFlowJSON: { [key: string]: unknown } = undefined,\n): Promise<FlowConnector> {\n    let connector: FlowConnector;\n    if (\n        inputedFlowJSON &&\n        typeof inputedFlowJSON === \"object\" &&\n        typeof inputedFlowJSON?.networks === \"object\" &&\n        typeof inputedFlowJSON?.dependencies === \"object\"\n    ) {\n        connector = await _createFlowConnector(runtime, inputedFlowJSON);\n    } else {\n        connector = await _createFlowConnector(runtime, flowJSON);\n    }\n    return connector;\n}\n\n/**\n * Connector provider\n */\n@injectable()\nexport class ConnectorProvider implements Provider, InjectableProvider<FlowConnector> {\n    private _connector: FlowConnector;\n\n    /**\n     * Initialize the Flow connector provider\n     * @param flowJSON The Flow JSON object\n     */\n    constructor(\n        @inject(CONSTANTS.FlowJSON)\n        private readonly flowJSON: Record<string, unknown>,\n    ) {}\n\n    /**\n     * Get the Flow connector instance\n     * @param runtime The runtime object from Eliza framework\n     */\n    async getInstance(runtime: IAgentRuntime): Promise<FlowConnector> {\n        if (!this._connector) {\n            this._connector = await getFlowConnectorInstance(runtime, this.flowJSON);\n        }\n        return this._connector;\n    }\n\n    /**\n     * Get the connector status\n     * @param runtime The runtime object from Eliza framework\n     */\n    async getConnectorStatus(runtime: IAgentRuntime): Promise<string> {\n        const instance = await this.getInstance(runtime);\n        let output = `Now user<${runtime.character.name}> connected to\\n`;\n        output += `Flow network: ${instance.network}\\n`;\n        output += `Flow Endpoint: ${instance.rpcEndpoint}\\n`;\n        return output;\n    }\n\n    /**\n     * Eliza provider `get` method\n     * @returns The message to be injected into the context\n     */\n    async get(runtime: IAgentRuntime, _message: Memory, state?: State): Promise<string | null> {\n        // For one session, only inject the wallet info once\n        if (state) {\n            const CONNECTOR_PROVIDER_SESSION_FLAG = \"connector-provider-session\";\n            if (state[CONNECTOR_PROVIDER_SESSION_FLAG]) {\n                return null;\n            }\n            state[CONNECTOR_PROVIDER_SESSION_FLAG] = true;\n        }\n\n        try {\n            return await this.getConnectorStatus(runtime);\n        } catch (error) {\n            elizaLogger.error(\"Error in Flow connector provider:\", error.message);\n            return null;\n        }\n    }\n}\n\n// Connector provider is bound to singleton scope\nglobalContainer.bind<ConnectorProvider>(ConnectorProvider).toSelf().inSingletonScope();\n\n// Export an extra the provider instance without using inversify\nexport const flowConnectorProvider = new ConnectorProvider(flowJSON);\n","/**\n * Constant Symbols used in the library\n */\nexport const CONSTANTS = {\n    FlowJSON: Symbol.for(\"FlowJSON\"),\n};\n","{\n    \"dependencies\": {\n        \"ArrayUtils\": {\n            \"source\": \"mainnet://a340dc0a4ec828ab.ArrayUtils\",\n            \"hash\": \"9e8f2d3e35be82da42b685045af834e16d23bcef1f322603ff91cedd1c9bbad9\",\n            \"aliases\": {\n                \"mainnet\": \"a340dc0a4ec828ab\",\n                \"testnet\": \"31ad40c07a2a9788\"\n            }\n        },\n        \"Burner\": {\n            \"source\": \"mainnet://f233dcee88fe0abe.Burner\",\n            \"hash\": \"71af18e227984cd434a3ad00bb2f3618b76482842bae920ee55662c37c8bf331\",\n            \"aliases\": {\n                \"emulator\": \"f8d6e0586b0a20c7\",\n                \"mainnet\": \"f233dcee88fe0abe\",\n                \"testnet\": \"9a0766d93b6608b7\"\n            }\n        },\n        \"CapabilityDelegator\": {\n            \"source\": \"mainnet://d8a7e05a7ac670c0.CapabilityDelegator\",\n            \"hash\": \"ad3bf8671a74a836b428da7840540c0ce419349be5f6410b18546e9a9217a9d2\",\n            \"aliases\": {\n                \"mainnet\": \"d8a7e05a7ac670c0\",\n                \"testnet\": \"294e44e1ec6993c6\"\n            }\n        },\n        \"CapabilityFactory\": {\n            \"source\": \"mainnet://d8a7e05a7ac670c0.CapabilityFactory\",\n            \"hash\": \"33d6b142c1db548a193cc06ff9828a24ca2ff8726301e292a8b6863dd0e1e73e\",\n            \"aliases\": {\n                \"mainnet\": \"d8a7e05a7ac670c0\",\n                \"testnet\": \"294e44e1ec6993c6\"\n            }\n        },\n        \"CapabilityFilter\": {\n            \"source\": \"mainnet://d8a7e05a7ac670c0.CapabilityFilter\",\n            \"hash\": \"77b59eb8245102a84a49d47a67e83eeeaafea920b120cdd6aa175d9ff120c388\",\n            \"aliases\": {\n                \"mainnet\": \"d8a7e05a7ac670c0\",\n                \"testnet\": \"294e44e1ec6993c6\"\n            }\n        },\n        \"CrossVMNFT\": {\n            \"source\": \"mainnet://1e4aa0b87d10b141.CrossVMNFT\",\n            \"hash\": \"a9e2ba34ecffda196c58f5c1439bc257d48d0c81457597eb58eb5f879dd95e5a\",\n            \"aliases\": {\n                \"mainnet\": \"1e4aa0b87d10b141\",\n                \"testnet\": \"dfc20aee650fcbdf\"\n            }\n        },\n        \"CrossVMToken\": {\n            \"source\": \"mainnet://1e4aa0b87d10b141.CrossVMToken\",\n            \"hash\": \"6d5c16804247ab9f1234b06383fa1bed42845211dba22582748abd434296650c\",\n            \"aliases\": {\n                \"mainnet\": \"1e4aa0b87d10b141\",\n                \"testnet\": \"dfc20aee650fcbdf\"\n            }\n        },\n        \"EVM\": {\n            \"source\": \"mainnet://e467b9dd11fa00df.EVM\",\n            \"hash\": \"5c69921fa06088b477e2758e122636b39d3d3eb5316807c206c5680d9ac74c7e\",\n            \"aliases\": {\n                \"emulator\": \"f8d6e0586b0a20c7\",\n                \"mainnet\": \"e467b9dd11fa00df\",\n                \"testnet\": \"8c5303eaa26202d6\"\n            }\n        },\n        \"FTViewUtils\": {\n            \"source\": \"mainnet://15a918087ab12d86.FTViewUtils\",\n            \"hash\": \"ef8343697ebcb455a835bc9f87b8060f574c3d968644de47f6613cebf05d7749\",\n            \"aliases\": {\n                \"mainnet\": \"15a918087ab12d86\",\n                \"testnet\": \"b86f928a1fa7798e\"\n            }\n        },\n        \"FlowEVMBridge\": {\n            \"source\": \"mainnet://1e4aa0b87d10b141.FlowEVMBridge\",\n            \"hash\": \"83d4d1f7c715cfe7b1a65241e94ae4b8cb40e6ce135ce4c3981e4d39e59ba33e\",\n            \"aliases\": {\n                \"mainnet\": \"1e4aa0b87d10b141\",\n                \"testnet\": \"dfc20aee650fcbdf\"\n            }\n        },\n        \"FlowEVMBridgeConfig\": {\n            \"source\": \"mainnet://1e4aa0b87d10b141.FlowEVMBridgeConfig\",\n            \"hash\": \"279513a6c107da2af4c847a42169f862ee67105e5a56512872fb6b9a9be3305d\",\n            \"aliases\": {\n                \"mainnet\": \"1e4aa0b87d10b141\",\n                \"testnet\": \"dfc20aee650fcbdf\"\n            }\n        },\n        \"FlowEVMBridgeHandlerInterfaces\": {\n            \"source\": \"mainnet://1e4aa0b87d10b141.FlowEVMBridgeHandlerInterfaces\",\n            \"hash\": \"fcbcd095c8145acf6fd07c336d44502f2946e32f4a1bf7e9bd0772fdd1bea778\",\n            \"aliases\": {\n                \"mainnet\": \"1e4aa0b87d10b141\",\n                \"testnet\": \"dfc20aee650fcbdf\"\n            }\n        },\n        \"FlowEVMBridgeNFTEscrow\": {\n            \"source\": \"mainnet://1e4aa0b87d10b141.FlowEVMBridgeNFTEscrow\",\n            \"hash\": \"ea7054bd06f978d09672ab2d6a1e7ad04df4b46410943088d555dd9ca6e64240\",\n            \"aliases\": {\n                \"mainnet\": \"1e4aa0b87d10b141\",\n                \"testnet\": \"dfc20aee650fcbdf\"\n            }\n        },\n        \"FlowEVMBridgeTemplates\": {\n            \"source\": \"mainnet://1e4aa0b87d10b141.FlowEVMBridgeTemplates\",\n            \"hash\": \"8f27b22450f57522d93d3045038ac9b1935476f4216f57fe3bb82929c71d7aa6\",\n            \"aliases\": {\n                \"mainnet\": \"1e4aa0b87d10b141\",\n                \"testnet\": \"dfc20aee650fcbdf\"\n            }\n        },\n        \"FlowEVMBridgeTokenEscrow\": {\n            \"source\": \"mainnet://1e4aa0b87d10b141.FlowEVMBridgeTokenEscrow\",\n            \"hash\": \"b5ec7c0a16e1c49004b2ed072c5eadc8c382e43351982b4a3050422f116b8f46\",\n            \"aliases\": {\n                \"mainnet\": \"1e4aa0b87d10b141\",\n                \"testnet\": \"dfc20aee650fcbdf\"\n            }\n        },\n        \"FlowEVMBridgeUtils\": {\n            \"source\": \"mainnet://1e4aa0b87d10b141.FlowEVMBridgeUtils\",\n            \"hash\": \"cd17ed82ae6d6f708a8d022d4228e0b53d2349f7f330c18e9c45e777553d2173\",\n            \"aliases\": {\n                \"mainnet\": \"1e4aa0b87d10b141\",\n                \"testnet\": \"dfc20aee650fcbdf\"\n            }\n        },\n        \"FlowStorageFees\": {\n            \"source\": \"mainnet://e467b9dd11fa00df.FlowStorageFees\",\n            \"hash\": \"e38d8a95f6518b8ff46ce57dfa37b4b850b3638f33d16333096bc625b6d9b51a\",\n            \"aliases\": {\n                \"emulator\": \"f8d6e0586b0a20c7\",\n                \"mainnet\": \"e467b9dd11fa00df\",\n                \"testnet\": \"8c5303eaa26202d6\"\n            }\n        },\n        \"FlowToken\": {\n            \"source\": \"mainnet://1654653399040a61.FlowToken\",\n            \"hash\": \"cefb25fd19d9fc80ce02896267eb6157a6b0df7b1935caa8641421fe34c0e67a\",\n            \"aliases\": {\n                \"emulator\": \"0ae53cb6e3f42a79\",\n                \"mainnet\": \"1654653399040a61\",\n                \"testnet\": \"7e60df042a9c0868\"\n            }\n        },\n        \"FungibleToken\": {\n            \"source\": \"mainnet://f233dcee88fe0abe.FungibleToken\",\n            \"hash\": \"050328d01c6cde307fbe14960632666848d9b7ea4fef03ca8c0bbfb0f2884068\",\n            \"aliases\": {\n                \"emulator\": \"ee82856bf20e2aa6\",\n                \"mainnet\": \"f233dcee88fe0abe\",\n                \"testnet\": \"9a0766d93b6608b7\"\n            }\n        },\n        \"FungibleTokenMetadataViews\": {\n            \"source\": \"mainnet://f233dcee88fe0abe.FungibleTokenMetadataViews\",\n            \"hash\": \"dff704a6e3da83997ed48bcd244aaa3eac0733156759a37c76a58ab08863016a\",\n            \"aliases\": {\n                \"emulator\": \"ee82856bf20e2aa6\",\n                \"mainnet\": \"f233dcee88fe0abe\",\n                \"testnet\": \"9a0766d93b6608b7\"\n            }\n        },\n        \"HybridCustody\": {\n            \"source\": \"mainnet://d8a7e05a7ac670c0.HybridCustody\",\n            \"hash\": \"c8a129eec11c57ee25487fcce38efc54c3b12eb539ba61a52f4ee620173bb67b\",\n            \"aliases\": {\n                \"mainnet\": \"d8a7e05a7ac670c0\",\n                \"testnet\": \"294e44e1ec6993c6\"\n            }\n        },\n        \"IBridgePermissions\": {\n            \"source\": \"mainnet://1e4aa0b87d10b141.IBridgePermissions\",\n            \"hash\": \"431a51a6cca87773596f79832520b19499fe614297eaef347e49383f2ae809af\",\n            \"aliases\": {\n                \"mainnet\": \"1e4aa0b87d10b141\",\n                \"testnet\": \"dfc20aee650fcbdf\"\n            }\n        },\n        \"ICrossVM\": {\n            \"source\": \"mainnet://1e4aa0b87d10b141.ICrossVM\",\n            \"hash\": \"e14dcb25f974e216fd83afdc0d0f576ae7014988755a4777b06562ffb06537bc\",\n            \"aliases\": {\n                \"mainnet\": \"1e4aa0b87d10b141\",\n                \"testnet\": \"dfc20aee650fcbdf\"\n            }\n        },\n        \"ICrossVMAsset\": {\n            \"source\": \"mainnet://1e4aa0b87d10b141.ICrossVMAsset\",\n            \"hash\": \"aa1fbd979c9d7806ea8ea66311e2a4257c5a4051eef020524a0bda4d8048ed57\",\n            \"aliases\": {\n                \"mainnet\": \"1e4aa0b87d10b141\",\n                \"testnet\": \"dfc20aee650fcbdf\"\n            }\n        },\n        \"IEVMBridgeNFTMinter\": {\n            \"source\": \"mainnet://1e4aa0b87d10b141.IEVMBridgeNFTMinter\",\n            \"hash\": \"65ec734429c12b70cd97ad8ea2c2bc4986fab286744921ed139d9b45da92e77e\",\n            \"aliases\": {\n                \"mainnet\": \"1e4aa0b87d10b141\",\n                \"testnet\": \"dfc20aee650fcbdf\"\n            }\n        },\n        \"IEVMBridgeTokenMinter\": {\n            \"source\": \"mainnet://1e4aa0b87d10b141.IEVMBridgeTokenMinter\",\n            \"hash\": \"223adb675415984e9c163d15c5922b5c77dc5036bf6548d0b87afa27f4f0a9d9\",\n            \"aliases\": {\n                \"mainnet\": \"1e4aa0b87d10b141\",\n                \"testnet\": \"dfc20aee650fcbdf\"\n            }\n        },\n        \"IFlowEVMNFTBridge\": {\n            \"source\": \"mainnet://1e4aa0b87d10b141.IFlowEVMNFTBridge\",\n            \"hash\": \"3d5bfa663a7059edee8c51d95bc454adf37f17c6d32be18eb42134b550e537b3\",\n            \"aliases\": {\n                \"mainnet\": \"1e4aa0b87d10b141\",\n                \"testnet\": \"dfc20aee650fcbdf\"\n            }\n        },\n        \"IFlowEVMTokenBridge\": {\n            \"source\": \"mainnet://1e4aa0b87d10b141.IFlowEVMTokenBridge\",\n            \"hash\": \"573a038b1e9c26504f6aa32a091e88168591b7f93feeff9ac0343285488a8eb3\",\n            \"aliases\": {\n                \"mainnet\": \"1e4aa0b87d10b141\",\n                \"testnet\": \"dfc20aee650fcbdf\"\n            }\n        },\n        \"MetadataViews\": {\n            \"source\": \"mainnet://1d7e57aa55817448.MetadataViews\",\n            \"hash\": \"10a239cc26e825077de6c8b424409ae173e78e8391df62750b6ba19ffd048f51\",\n            \"aliases\": {\n                \"emulator\": \"f8d6e0586b0a20c7\",\n                \"mainnet\": \"1d7e57aa55817448\",\n                \"testnet\": \"631e88ae7f1d7c20\"\n            }\n        },\n        \"NonFungibleToken\": {\n            \"source\": \"mainnet://1d7e57aa55817448.NonFungibleToken\",\n            \"hash\": \"b63f10e00d1a814492822652dac7c0574428a200e4c26cb3c832c4829e2778f0\",\n            \"aliases\": {\n                \"emulator\": \"f8d6e0586b0a20c7\",\n                \"mainnet\": \"1d7e57aa55817448\",\n                \"testnet\": \"631e88ae7f1d7c20\"\n            }\n        },\n        \"OracleConfig\": {\n            \"source\": \"mainnet://cec15c814971c1dc.OracleConfig\",\n            \"hash\": \"48c252a858ce1c1fb44a377f338a4e558a70f1c22cecea9b7bf8cb74e9b16b79\",\n            \"aliases\": {\n                \"mainnet\": \"cec15c814971c1dc\",\n                \"testnet\": \"2a9b59c3e2b72ee0\"\n            }\n        },\n        \"OracleInterface\": {\n            \"source\": \"mainnet://cec15c814971c1dc.OracleInterface\",\n            \"hash\": \"1ca66227b60dcf59e9d84404398c8151b1ff6395408094669ef1251c78ca2465\",\n            \"aliases\": {\n                \"mainnet\": \"cec15c814971c1dc\",\n                \"testnet\": \"2a9b59c3e2b72ee0\"\n            }\n        },\n        \"PublicPriceOracle\": {\n            \"source\": \"mainnet://ec67451f8a58216a.PublicPriceOracle\",\n            \"hash\": \"3f0b75a98cc8a75835125421bcf602a3f278eaf94001bca7b7a8503b73cbc9a7\",\n            \"aliases\": {\n                \"mainnet\": \"ec67451f8a58216a\",\n                \"testnet\": \"8232ce4a3aff4e94\"\n            }\n        },\n        \"ScopedFTProviders\": {\n            \"source\": \"mainnet://a340dc0a4ec828ab.ScopedFTProviders\",\n            \"hash\": \"9a143138f5a5f51a5402715f7d84dbe363b5744be153ee09343aed71cf241c42\",\n            \"aliases\": {\n                \"mainnet\": \"a340dc0a4ec828ab\",\n                \"testnet\": \"31ad40c07a2a9788\"\n            }\n        },\n        \"Serialize\": {\n            \"source\": \"mainnet://1e4aa0b87d10b141.Serialize\",\n            \"hash\": \"d12a5957ab5352024bb08b281c4de4f9a88ecde74b159a7da0c69d0c8ca51589\",\n            \"aliases\": {\n                \"mainnet\": \"1e4aa0b87d10b141\",\n                \"testnet\": \"dfc20aee650fcbdf\"\n            }\n        },\n        \"SerializeMetadata\": {\n            \"source\": \"mainnet://1e4aa0b87d10b141.SerializeMetadata\",\n            \"hash\": \"eb7ec0ab5abfc66dd636c07a5ed2c7a65723a8d876842035bf9bebd6b0060e3a\",\n            \"aliases\": {\n                \"mainnet\": \"1e4aa0b87d10b141\",\n                \"testnet\": \"dfc20aee650fcbdf\"\n            }\n        },\n        \"StableSwapFactory\": {\n            \"source\": \"mainnet://b063c16cac85dbd1.StableSwapFactory\",\n            \"hash\": \"46318aee6fd29616c8048c23210d4c4f5b172eb99a0ca911fbd849c831a52a0b\",\n            \"aliases\": {\n                \"mainnet\": \"b063c16cac85dbd1\",\n                \"testnet\": \"cbed4c301441ded2\"\n            }\n        },\n        \"StringUtils\": {\n            \"source\": \"mainnet://a340dc0a4ec828ab.StringUtils\",\n            \"hash\": \"b401c4b0f711344ed9cd02ff77c91e026f5dfbca6045f140b9ca9d4966707e83\",\n            \"aliases\": {\n                \"mainnet\": \"a340dc0a4ec828ab\",\n                \"testnet\": \"31ad40c07a2a9788\"\n            }\n        },\n        \"SwapConfig\": {\n            \"source\": \"mainnet://b78ef7afa52ff906.SwapConfig\",\n            \"hash\": \"ccafdb89804887e4e39a9b8fdff5c0ff0d0743505282f2a8ecf86c964e691c82\",\n            \"aliases\": {\n                \"mainnet\": \"b78ef7afa52ff906\",\n                \"testnet\": \"ddb929038d45d4b3\"\n            }\n        },\n        \"SwapError\": {\n            \"source\": \"mainnet://b78ef7afa52ff906.SwapError\",\n            \"hash\": \"7d13a652a1308af387513e35c08b4f9a7389a927bddf08431687a846e4c67f21\",\n            \"aliases\": {\n                \"mainnet\": \"b78ef7afa52ff906\",\n                \"testnet\": \"ddb929038d45d4b3\"\n            }\n        },\n        \"SwapFactory\": {\n            \"source\": \"mainnet://b063c16cac85dbd1.SwapFactory\",\n            \"hash\": \"6d319e77f5eed0c49c960b1ef887c01dd7c2cce8a0b39f7e31fb2af0113eedc5\",\n            \"aliases\": {\n                \"mainnet\": \"b063c16cac85dbd1\",\n                \"testnet\": \"cbed4c301441ded2\"\n            }\n        },\n        \"SwapInterfaces\": {\n            \"source\": \"mainnet://b78ef7afa52ff906.SwapInterfaces\",\n            \"hash\": \"570bb4b9c8da8e0caa8f428494db80779fb906a66cc1904c39a2b9f78b89c6fa\",\n            \"aliases\": {\n                \"mainnet\": \"b78ef7afa52ff906\",\n                \"testnet\": \"ddb929038d45d4b3\"\n            }\n        },\n        \"SwapPair\": {\n            \"source\": \"mainnet://ecbda466e7f191c7.SwapPair\",\n            \"hash\": \"69b99c4a8abc123a0a88b1c354f9da414a32e2f73194403e67e89d51713923c0\",\n            \"aliases\": {\n                \"mainnet\": \"ecbda466e7f191c7\",\n                \"testnet\": \"c20df20fabe06457\"\n            }\n        },\n        \"TokenList\": {\n            \"source\": \"mainnet://15a918087ab12d86.TokenList\",\n            \"hash\": \"ac9298cfdf02e785e92334858fab0f388e5a72136c3bc4d4ed7f2039ac152bd5\",\n            \"aliases\": {\n                \"mainnet\": \"15a918087ab12d86\",\n                \"testnet\": \"b86f928a1fa7798e\"\n            }\n        },\n        \"ViewResolver\": {\n            \"source\": \"mainnet://1d7e57aa55817448.ViewResolver\",\n            \"hash\": \"374a1994046bac9f6228b4843cb32393ef40554df9bd9907a702d098a2987bde\",\n            \"aliases\": {\n                \"emulator\": \"f8d6e0586b0a20c7\",\n                \"mainnet\": \"1d7e57aa55817448\",\n                \"testnet\": \"631e88ae7f1d7c20\"\n            }\n        },\n        \"ViewResolvers\": {\n            \"source\": \"mainnet://15a918087ab12d86.ViewResolvers\",\n            \"hash\": \"37ef9b2a71c1b0daa031c261f731466fcbefad998590177c798b56b61a95489a\",\n            \"aliases\": {\n                \"mainnet\": \"15a918087ab12d86\",\n                \"testnet\": \"b86f928a1fa7798e\"\n            }\n        },\n        \"stFlowToken\": {\n            \"source\": \"mainnet://d6f80565193ad727.stFlowToken\",\n            \"hash\": \"09b1350a55646fdee652fddf7927fc4b305da5a265cb1bd887e112d84fb5e2be\",\n            \"aliases\": {\n                \"mainnet\": \"d6f80565193ad727\",\n                \"testnet\": \"e45c64ecfe31e465\"\n            }\n        }\n    },\n    \"networks\": {\n        \"emulator\": \"127.0.0.1:3569\",\n        \"mainnet\": \"access.mainnet.nodes.onflow.org:9000\",\n        \"testing\": \"127.0.0.1:3569\",\n        \"testnet\": \"access.devnet.nodes.onflow.org:9000\"\n    }\n}\n","import { injectable, inject } from \"inversify\";\nimport {\n    elizaLogger,\n    type IAgentRuntime,\n    type Memory,\n    type Provider,\n    type State,\n} from \"@elizaos/core\";\nimport { globalContainer, type InjectableProvider } from \"@elizaos-plugins/plugin-di\";\nimport { ConnectorProvider, flowConnectorProvider } from \"./connector\";\nimport { FlowWallet } from \"./utils/flow.wallet\";\nimport { queryAccountBalanceInfo } from \"../queries\";\nimport { formatWalletBalances } from \"../helpers\";\n\n/**\n * Wallet provider\n */\n@injectable()\nexport class WalletProvider implements Provider, InjectableProvider<FlowWallet> {\n    private _wallet: FlowWallet;\n\n    constructor(\n        @inject(ConnectorProvider)\n        private readonly connector: ConnectorProvider,\n    ) {}\n\n    /**\n     * Get the Flow wallet instance\n     * @param runtime The runtime object from Eliza framework\n     */\n    async getInstance(runtime: IAgentRuntime): Promise<FlowWallet> {\n        if (!this._wallet) {\n            const connectorIns = await this.connector.getInstance(runtime);\n            this._wallet = new FlowWallet(runtime, connectorIns);\n        }\n        return this._wallet;\n    }\n\n    /**\n     * Eliza provider `get` method\n     * @returns The message to be injected into the context\n     */\n    async get(runtime: IAgentRuntime, _message: Memory, state?: State): Promise<string | null> {\n        // For one session, only inject the wallet info once\n        if (state) {\n            const WALLET_PROVIDER_SESSION_FLAG = \"wallet-provider-session\";\n            if (state[WALLET_PROVIDER_SESSION_FLAG]) {\n                return null;\n            }\n            state[WALLET_PROVIDER_SESSION_FLAG] = true;\n        }\n\n        // Check if the user has an Flow wallet\n        if (!runtime.getSetting(\"FLOW_ADDRESS\") || !runtime.getSetting(\"FLOW_PRIVATE_KEY\")) {\n            elizaLogger.error(\n                \"FLOW_ADDRESS or FLOW_PRIVATE_KEY not configured, skipping wallet injection\",\n            );\n            return null;\n        }\n\n        try {\n            const walletProvider = await this.getInstance(runtime);\n            const info = await queryAccountBalanceInfo(walletProvider, walletProvider.address);\n            if (!info || info?.address !== walletProvider.address) {\n                elizaLogger.error(\"Invalid account info\");\n                return null;\n            }\n            let output = `Here is user<${runtime.character.name}>'s wallet status:\\n`;\n            output += formatWalletBalances(info);\n            return output;\n        } catch (error) {\n            elizaLogger.error(\"Error in Flow wallet provider:\", error.message);\n            return null;\n        }\n    }\n}\n\n// Wallet provider is bound to request scope\nglobalContainer.bind<WalletProvider>(WalletProvider).toSelf().inRequestScope();\n\n// Export an extra the provider instance without using inversify\nexport const flowWalletProvider = new WalletProvider(flowConnectorProvider);\n","import { scripts } from \"./assets/script.defs\";\nimport type { FlowAccountBalanceInfo, IFlowScriptExecutor } from \"./types\";\n\n/**\n * Query the balance of an EVM ERC20 token\n * @param executor\n * @param owner\n * @param evmContractAddress\n */\nexport async function queryEvmERC20BalanceOf(\n    executor: IFlowScriptExecutor,\n    owner: string,\n    evmContractAddress: string\n): Promise<bigint> {\n    const ret = await executor.executeScript(\n        scripts.evmERC20BalanceOf,\n        (arg, t) => [arg(owner, t.String), arg(evmContractAddress, t.String)],\n        BigInt(0)\n    );\n    return BigInt(ret);\n}\n\n/**\n * Query the decimals of an EVM ERC20 token\n * @param executor\n * @param evmContractAddress\n */\nexport async function queryEvmERC20Decimals(\n    executor: IFlowScriptExecutor,\n    evmContractAddress: string\n): Promise<number> {\n    const ret = await executor.executeScript(\n        scripts.evmERC20GetDecimals,\n        (arg, t) => [arg(evmContractAddress, t.String)],\n        \"0\"\n    );\n    return Number.parseInt(ret);\n}\n\n/**\n * Query the total supply of an EVM ERC20 token\n * @param executor\n * @param evmContractAddress\n */\nexport async function queryEvmERC20TotalSupply(\n    executor: IFlowScriptExecutor,\n    evmContractAddress: string\n): Promise<bigint> {\n    const ret = await executor.executeScript(\n        scripts.evmERC20GetTotalSupply,\n        (arg, t) => [arg(evmContractAddress, t.String)],\n        BigInt(0)\n    );\n    return BigInt(ret);\n}\n\n/**\n * Query the account info of a Flow address\n * @param executor\n * @param address\n */\nexport async function queryAccountBalanceInfo(\n    executor: IFlowScriptExecutor,\n    address: string\n): Promise<FlowAccountBalanceInfo | undefined> {\n    const ret = await executor.executeScript(\n        scripts.mainGetAccountInfo,\n        (arg, t) => [arg(address, t.Address)],\n        undefined\n    );\n    if (!ret) {\n        return undefined;\n    }\n    return {\n        address: ret.address,\n        balance: Number.parseFloat(ret.balance),\n        coaAddress: ret.coaAddress,\n        coaBalance: ret.coaBalance ? Number.parseFloat(ret.coaBalance) : undefined,\n    };\n}\n","import \"EVM\"\n\naccess(all) fun getTypeArray(_ identifiers: [String]): [Type] {\n    var types: [Type] = []\n    for identifier in identifiers {\n        let type = CompositeType(identifier)\n            ?? panic(\"Invalid identifier: \".concat(identifier))\n        types.append(type)\n    }\n    return types\n}\n\n/// Supports generic calls to EVM contracts that might have return values\n///\naccess(all) fun main(\n    gatewayAddress: Address,\n    evmContractAddressHex: String,\n    calldata: String,\n    gasLimit: UInt64,\n    typeIdentifiers: [String]\n): [AnyStruct] {\n\n    let evmAddress = EVM.addressFromString(evmContractAddressHex)\n\n    let data = calldata.decodeHex()\n\n    let gatewayCOA = getAuthAccount<auth(BorrowValue) &Account>(gatewayAddress)\n        .storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(\n            from: /storage/evm\n        ) ?? panic(\"Could not borrow COA from provided gateway address\")\n\n    let evmResult = gatewayCOA.call(\n        to: evmAddress,\n        data: data,\n        gasLimit: gasLimit,\n        value: EVM.Balance(attoflow: 0)\n    )\n\n    return EVM.decodeABI(types: getTypeArray(typeIdentifiers), data: evmResult.data)\n}\n","import \"EVM\"\n\nimport \"FlowEVMBridgeUtils\"\n\n/// Returns the balance of the owner (hex-encoded EVM address) of a given ERC20 fungible token defined\n/// at the hex-encoded EVM contract address\n///\n/// @param owner: The hex-encoded EVM address of the owner\n/// @param evmContractAddress: The hex-encoded EVM contract address of the ERC20 contract\n///\n/// @return The balance of the address, reverting if the given contract address does not implement the ERC20 method\n///     \"balanceOf(address)(uint256)\"\n///\naccess(all) fun main(owner: String, evmContractAddress: String): UInt256 {\n    return FlowEVMBridgeUtils.balanceOf(\n        owner: EVM.addressFromString(owner),\n        evmContractAddress: EVM.addressFromString(evmContractAddress)\n    )\n}\n","import \"EVM\"\n\nimport \"FlowEVMBridgeUtils\"\n\naccess(all)\nfun main(erc20ContractAddressHex: String): UInt8 {\n    return FlowEVMBridgeUtils.getTokenDecimals(\n        evmContractAddress: EVM.addressFromString(erc20ContractAddressHex)\n    )\n}\n","import \"EVM\"\n\nimport \"FlowEVMBridgeUtils\"\n\n/// Retrieves the total supply of the ERC20 contract at the given EVM contract address. Reverts on EVM call failure.\n///\n/// @param evmContractAddress: The EVM contract address to retrieve the total supply from\n///\n/// @return the total supply of the ERC20\n///\naccess(all) fun main(evmContractAddressHex: String): UInt256 {\n    return FlowEVMBridgeUtils.totalSupply(\n        evmContractAddress: EVM.addressFromString(evmContractAddressHex)\n    )\n}\n","import \"FungibleToken\"\nimport \"EVM\"\n\n/// Returns the hex encoded address of the COA in the given Flow address\n///\naccess(all) fun main(flowAddress: Address): AccountInfo {\n    var flowBalance: UFix64 = 0.0\n    if let flowVaultRef = getAccount(flowAddress)\n        .capabilities.get<&{FungibleToken.Balance}>(/public/flowTokenBalance)\n        .borrow() {\n        flowBalance = flowVaultRef.balance\n    }\n\n    var coaAddress: String? = nil\n    var coaBalance: UFix64? = nil\n\n    if let address: EVM.EVMAddress = getAuthAccount<auth(BorrowValue) &Account>(flowAddress)\n        .storage.borrow<&EVM.CadenceOwnedAccount>(from: /storage/evm)?.address() {\n        let bytes: [UInt8] = []\n        for byte in address.bytes {\n            bytes.append(byte)\n        }\n        coaAddress = String.encodeHex(bytes)\n        coaBalance = address.balance().inFLOW()\n    }\n    return AccountInfo(\n        flowAddress,\n        flowBalance,\n        coaAddress,\n        coaBalance\n    )\n}\n\naccess(all) struct AccountInfo {\n    access(all) let address: Address\n    access(all) let balance: UFix64\n    access(all) let coaAddress: String?\n    access(all) let coaBalance: UFix64?\n\n    init(\n        _ address: Address,\n        _ balance: UFix64,\n        _ coaAddress: String?,\n        _ coaBalance: UFix64?\n    ) {\n        self.address = address\n        self.balance = balance\n        self.coaAddress = coaAddress\n        self.coaBalance = coaBalance\n    }\n}\n","// Source:\n//\n// This file contains the definitions of the Cadence scripts used in the plugin.\n// The scripts are defined as strings and exported as a dictionary.\n\n// Scripts for EVM\nimport evmCall from \"./cadence/scripts/evm/call.cdc\";\nimport evmERC20BalanceOf from \"./cadence/scripts/evm/erc20/balance_of.cdc\";\nimport evmERC20GetDecimals from \"./cadence/scripts/evm/erc20/get_decimals.cdc\";\nimport evmERC20GetTotalSupply from \"./cadence/scripts/evm/erc20/total_supply.cdc\";\n\n// Scripts for main account\nimport mainGetAccountInfo from \"./cadence/scripts/main-account/get_acct_info.cdc\";\n\nexport const scripts = {\n    evmCall,\n    evmERC20BalanceOf,\n    evmERC20GetDecimals,\n    evmERC20GetTotalSupply,\n    mainGetAccountInfo,\n};\n","import fs from \"node:fs\";\nimport path from \"node:path\";\nimport { elizaLogger } from \"@elizaos/core\";\nimport { globalContainer } from \"@elizaos-plugins/plugin-di\";\nimport { CONSTANTS } from \"./symbols\";\n\n// Load flow.json file and bind it to the container\nglobalContainer.bind<Record<string, unknown>>(CONSTANTS.FlowJSON).toDynamicValue(async () => {\n    // Search `flow.json` from the runtime\n    const cwd = process.cwd();\n    // Try different path resolutions in order\n    const pathsToTry = [\n        path.resolve(cwd, \"flow.json\"), // relative to cwd\n        path.resolve(cwd, \"agent\", \"flow.json\"), // Add this\n        path.resolve(cwd, \"../flow.json\"),\n        path.resolve(cwd, \"../../flow.json\"),\n        path.resolve(cwd, \"../../../flow.json\"),\n    ];\n    elizaLogger.info(\n        \"Trying loading 'flow.json' paths:\",\n        pathsToTry.map((p) => ({\n            path: p,\n            exists: fs.existsSync(p),\n        })),\n    );\n\n    let jsonObjcet: Record<string, unknown> | null = null;\n    for (const tryPath of pathsToTry) {\n        try {\n            jsonObjcet = (await import(tryPath, { with: { type: \"json\" } })).default;\n            if (jsonObjcet) {\n                elizaLogger.info(`Successfully loaded 'flow.json' from: ${tryPath}`);\n                break;\n            }\n        } catch {\n            // Do nothing\n        }\n    }\n    if (!jsonObjcet) {\n        elizaLogger.error(\"Cannot find 'flow.json' file\");\n        throw new Error(\"Cannot find 'flow.json' file\");\n    }\n    return jsonObjcet;\n});\n","import \"EVM\"\n\n/// Executes the calldata from the signer's COA\n///\ntransaction(evmContractAddressHex: String, calldata: String, gasLimit: UInt64, value: UFix64) {\n\n    let evmAddress: EVM.EVMAddress\n    let coa: auth(EVM.Call) &EVM.CadenceOwnedAccount\n\n    prepare(signer: auth(BorrowValue) &Account) {\n        self.evmAddress = EVM.addressFromString(evmContractAddressHex)\n\n        let storagePath = StoragePath(identifier: \"evm\")!\n        let publicPath = PublicPath(identifier: \"evm\")!\n\n        // Reference signer's COA if one exists\n        let coa = signer.storage.borrow<auth(EVM.Withdraw) &EVM.CadenceOwnedAccount>(from: storagePath)\n        if coa == nil {\n            let coa <- EVM.createCadenceOwnedAccount()\n            signer.storage.save<@EVM.CadenceOwnedAccount>(<-coa, to: storagePath)\n            let addressableCap = signer.capabilities.storage.issue<&EVM.CadenceOwnedAccount>(storagePath)\n            signer.capabilities.unpublish(publicPath)\n            signer.capabilities.publish(addressableCap, at: publicPath)\n        }\n\n        self.coa = signer.storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(from: storagePath)\n            ?? panic(\"Could not borrow COA from provided gateway address\")\n    }\n\n    execute {\n        let valueBalance = EVM.Balance(attoflow: 0)\n        valueBalance.setFLOW(flow: value)\n        let callResult = self.coa.call(\n            to: self.evmAddress,\n            data: calldata.decodeHex(),\n            gasLimit: gasLimit,\n            value: valueBalance\n        )\n        assert(callResult.status == EVM.Status.successful, message: \"Call failed\")\n    }\n}\n","import Crypto\n\nimport \"EVM\"\n\n/// Creates a new Flow Address with a single full-weight key and its EVM account, which is\n/// a Cadence Owned Account (COA) stored in the account's storage.\n///\ntransaction(\n    key: String,  // key to be used for the account\n    signatureAlgorithm: UInt8, // signature algorithm to be used for the account\n    hashAlgorithm: UInt8, // hash algorithm to be used for the account\n) {\n    let auth: auth(BorrowValue) &Account\n\n    prepare(signer: auth(BorrowValue) &Account) {\n        pre {\n            signatureAlgorithm == 1 || signatureAlgorithm == 2:\n                \"Cannot add Key: Must provide a signature algorithm raw value that corresponds to \"\n                .concat(\"one of the available signature algorithms for Flow keys.\")\n                .concat(\"You provided \").concat(signatureAlgorithm.toString())\n                .concat(\" but the options are either 1 (ECDSA_P256), 2 (ECDSA_secp256k1).\")\n            hashAlgorithm == 1 || hashAlgorithm == 3:\n                \"Cannot add Key: Must provide a hash algorithm raw value that corresponds to \"\n                .concat(\"one of of the available hash algorithms for Flow keys.\")\n                .concat(\"You provided \").concat(hashAlgorithm.toString())\n                .concat(\" but the options are 1 (SHA2_256), 3 (SHA3_256).\")\n        }\n\n        self.auth = signer\n    }\n\n    execute {\n        // Create a new public key\n        let publicKey = PublicKey(\n            publicKey: key.decodeHex(),\n            signatureAlgorithm: SignatureAlgorithm(rawValue: signatureAlgorithm)!\n        )\n\n        // Create a new account\n        let account = Account(payer: self.auth)\n\n        // Add the public key to the account\n        account.keys.add(\n            publicKey: publicKey,\n            hashAlgorithm: HashAlgorithm(rawValue: hashAlgorithm)!,\n            weight: 1000.0\n        )\n\n        // Create a new COA\n        let coa <- EVM.createCadenceOwnedAccount()\n\n        // Save the COA to the new account\n        let storagePath = StoragePath(identifier: \"evm\")!\n        let publicPath = PublicPath(identifier: \"evm\")!\n        account.storage.save<@EVM.CadenceOwnedAccount>(<-coa, to: storagePath)\n        let addressableCap = account.capabilities.storage.issue<&EVM.CadenceOwnedAccount>(storagePath)\n        account.capabilities.unpublish(publicPath)\n        account.capabilities.publish(addressableCap, at: publicPath)\n    }\n}\n","import \"EVM\"\nimport \"FungibleToken\"\nimport \"FlowToken\"\n\n/// Creates a COA and saves it in the signer's Flow account & passing the given value of Flow into FlowEVM\n///\ntransaction() {\n\n    prepare(signer: auth(BorrowValue, IssueStorageCapabilityController, PublishCapability, SaveValue, UnpublishCapability) &Account) {\n        let storagePath = StoragePath(identifier: \"evm\")!\n        let publicPath = PublicPath(identifier: \"evm\")!\n\n        // Reference signer's COA if one exists\n        let coa = signer.storage.borrow<auth(EVM.Withdraw) &EVM.CadenceOwnedAccount>(from: storagePath)\n        if coa == nil {\n            let coa <- EVM.createCadenceOwnedAccount()\n            signer.storage.save<@EVM.CadenceOwnedAccount>(<-coa, to: storagePath)\n            let addressableCap = signer.capabilities.storage.issue<&EVM.CadenceOwnedAccount>(storagePath)\n            signer.capabilities.unpublish(publicPath)\n            signer.capabilities.publish(addressableCap, at: publicPath)\n        }\n    }\n}\n","import \"EVM\"\n\nimport \"FlowEVMBridgeUtils\"\n\n/// Executes a token transfer to the defined recipient address against the specified ERC20 contract.\n///\ntransaction(evmContractAddressHex: String, recipientAddressHex: String, amount: UInt256) {\n\n    let evmContractAddress: EVM.EVMAddress\n    let recipientAddress: EVM.EVMAddress\n    let coa: auth(EVM.Call) &EVM.CadenceOwnedAccount\n    let preBalance: UInt256\n    var postBalance: UInt256\n\n    prepare(signer: auth(BorrowValue) &Account) {\n        self.evmContractAddress = EVM.addressFromString(evmContractAddressHex)\n        self.recipientAddress = EVM.addressFromString(recipientAddressHex)\n\n        self.coa = signer.storage.borrow<auth(EVM.Call) &EVM.CadenceOwnedAccount>(from: /storage/evm)\n            ?? panic(\"Could not borrow CadenceOwnedAccount reference\")\n\n        self.preBalance = FlowEVMBridgeUtils.balanceOf(owner: self.coa.address(), evmContractAddress: self.evmContractAddress)\n        self.postBalance = 0\n    }\n\n    execute {\n        let calldata = EVM.encodeABIWithSignature(\"transfer(address,uint256)\", [self.recipientAddress, amount])\n        let callResult = self.coa.call(\n            to: self.evmContractAddress,\n            data: calldata,\n            gasLimit: 15_000_000,\n            value: EVM.Balance(attoflow: 0)\n        )\n        assert(callResult.status == EVM.Status.successful, message: \"Call to ERC20 contract failed\")\n        self.postBalance = FlowEVMBridgeUtils.balanceOf(owner: self.coa.address(), evmContractAddress: self.evmContractAddress)\n    }\n\n    post {\n        self.postBalance == self.preBalance - amount: \"Transfer failed\"\n    }\n}\n","import \"FungibleToken\"\nimport \"FlowToken\"\n\nimport \"EVM\"\n\n// Transfers $FLOW from the signer's account to the recipient's address, determining the target VM based on the format\n// of the recipient's hex address. Note that the sender's funds are sourced by default from the target VM, pulling any\n// difference from the alternate VM if available. e.g. Transfers to Flow addresses will first attempt to withdraw from\n// the signer's Flow vault, pulling any remaining funds from the signer's EVM account if available. Transfers to EVM\n// addresses will first attempt to withdraw from the signer's EVM account, pulling any remaining funds from the signer's\n// Flow vault if available. If the signer's balance across both VMs is insufficient, the transaction will revert.\n///\n/// @param addressString: The recipient's address in hex format - this should be either an EVM address or a Flow address\n/// @param amount: The amount of $FLOW to transfer as a UFix64 value\n///\ntransaction(addressString: String, amount: UFix64) {\n\n    let sentVault: @FlowToken.Vault\n    let evmRecipient: EVM.EVMAddress?\n    var receiver: &{FungibleToken.Receiver}?\n\n    prepare(signer: auth(BorrowValue, SaveValue) &Account) {\n        // Reference signer's COA if one exists\n        let coa = signer.storage.borrow<auth(EVM.Withdraw) &EVM.CadenceOwnedAccount>(from: /storage/evm)\n\n        // Reference signer's FlowToken Vault\n        let sourceVault = signer.storage.borrow<auth(FungibleToken.Withdraw) &FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Could not borrow signer's FlowToken.Vault\")\n        let cadenceBalance = sourceVault.balance\n\n        // Define optional recipients for both VMs\n        self.receiver = nil\n        let cadenceRecipient = Address.fromString(addressString)\n        self.evmRecipient = cadenceRecipient == nil ? EVM.addressFromString(addressString) : nil\n        // Validate exactly one target address is assigned\n        if cadenceRecipient != nil && self.evmRecipient != nil {\n            panic(\"Malformed recipient address - assignable as both Cadence and EVM addresses\")\n        } else if cadenceRecipient == nil && self.evmRecipient == nil {\n            panic(\"Malformed recipient address - not assignable as either Cadence or EVM address\")\n        }\n\n        // Create empty FLOW vault to capture funds\n        self.sentVault <- FlowToken.createEmptyVault(vaultType: Type<@FlowToken.Vault>())\n        /// If the target VM is Flow, does the Vault have sufficient balance to cover?\n        if cadenceRecipient != nil {\n            // Assign the Receiver of the $FLOW transfer\n            self.receiver = getAccount(cadenceRecipient!).capabilities.borrow<&{FungibleToken.Receiver}>(\n                    /public/flowTokenReceiver\n                ) ?? panic(\"Could not borrow reference to recipient's FungibleToken.Receiver\")\n\n            // Withdraw from the signer's Cadence Vault and deposit to sentVault\n            var withdrawAmount = amount < cadenceBalance ? amount : cadenceBalance\n            self.sentVault.deposit(from: <-sourceVault.withdraw(amount: withdrawAmount))\n\n            // If the cadence balance didn't cover the amount, check the signer's EVM balance\n            if amount > self.sentVault.balance {\n                let difference = amount - cadenceBalance\n                // Revert if the signer doesn't have an EVM account or EVM balance is insufficient\n                if coa == nil || difference < coa!.balance().inFLOW() {\n                    panic(\"Insufficient balance across Flow and EVM accounts\")\n                }\n\n                // Withdraw from the signer's EVM account and deposit to sentVault\n                let withdrawFromEVM = EVM.Balance(attoflow: 0)\n                withdrawFromEVM.setFLOW(flow: difference)\n                self.sentVault.deposit(from: <-coa!.withdraw(balance: withdrawFromEVM))\n            }\n        } else if self.evmRecipient != nil {\n            // Check signer's balance can cover the amount\n            if coa != nil {\n                // Determine the amount to withdraw from the signer's EVM account\n                let balance = coa!.balance()\n                let withdrawAmount = amount < balance.inFLOW() ? amount : balance.inFLOW()\n                balance.setFLOW(flow: withdrawAmount)\n\n                // Withdraw funds from EVM to the sentVault\n                self.sentVault.deposit(from: <-coa!.withdraw(balance: balance))\n            }\n            if amount > self.sentVault.balance {\n                // Insufficient amount withdrawn from EVM, check signer's Flow balance\n                let difference = amount - self.sentVault.balance\n                if difference > cadenceBalance {\n                    panic(\"Insufficient balance across Flow and EVM accounts\")\n                }\n                // Withdraw from the signer's Cadence Vault and deposit to sentVault\n                self.sentVault.deposit(from: <-sourceVault.withdraw(amount: difference))\n            }\n        }\n    }\n\n    pre {\n        self.sentVault.balance == amount: \"Attempting to send an incorrect amount of $FLOW\"\n    }\n\n    execute {\n        // Complete Cadence transfer if the FungibleToken Receiver is assigned\n        if self.receiver != nil {\n            self.receiver!.deposit(from: <-self.sentVault)\n        } else {\n            // Otherwise, complete EVM transfer\n            self.evmRecipient!.deposit(from: <-self.sentVault)\n        }\n    }\n}\n","import \"FungibleToken\"\nimport \"FungibleTokenMetadataViews\"\n\n#interaction (\n  version: \"1.0.0\",\n\ttitle: \"Generic FT Transfer with Contract Address and Name\",\n\tdescription: \"Transfer any Fungible Token by providing the contract address and name\",\n\tlanguage: \"en-US\",\n)\n\n/// Can pass in any contract address and name to transfer a token from that contract\n/// This lets you choose the token you want to send\n///\n/// Any contract can be chosen here, so wallets should check argument values\n/// to make sure the intended token contract name and address is passed in\n/// Contracts that are used must implement the FTVaultData Metadata View\n///\n/// Note: This transaction only will work for Fungible Tokens that\n///       have their token's resource name set as \"Vault\".\n///       Tokens with other names will need to use a different transaction\n///       that additionally specifies the identifier\n///\n/// @param amount: The amount of tokens to transfer\n/// @param to: The address to transfer the tokens to\n/// @param contractAddress: The address of the contract that defines the tokens being transferred\n/// @param contractName: The name of the contract that defines the tokens being transferred. Ex: \"FlowToken\"\n///\ntransaction(amount: UFix64, to: Address, contractAddress: Address, contractName: String) {\n\n    // The Vault resource that holds the tokens that are being transferred\n    let tempVault: @{FungibleToken.Vault}\n\n    // FTVaultData struct to get paths from\n    let vaultData: FungibleTokenMetadataViews.FTVaultData\n\n    prepare(signer: auth(BorrowValue) &Account) {\n\n        // Borrow a reference to the vault stored on the passed account at the passed publicPath\n        let resolverRef = getAccount(contractAddress)\n            .contracts.borrow<&{FungibleToken}>(name: contractName)\n                ?? panic(\"Could not borrow FungibleToken reference to the contract. Make sure the provided contract name (\"\n                          .concat(contractName).concat(\") and address (\").concat(contractAddress.toString()).concat(\") are correct!\"))\n\n        // Use that reference to retrieve the FTView\n        self.vaultData = resolverRef.resolveContractView(resourceType: nil, viewType: Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?\n            ?? panic(\"Could not resolve FTVaultData view. The \".concat(contractName)\n                .concat(\" contract needs to implement the FTVaultData Metadata view in order to execute this transaction.\"))\n\n        // Get a reference to the signer's stored vault\n        let vaultRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(from: self.vaultData.storagePath)\n\t\t\t?? panic(\"The signer does not store a FungibleToken.Provider object at the path \"\n                .concat(self.vaultData.storagePath.toString()).concat(\"For the \").concat(contractName)\n                .concat(\" contract at address \").concat(contractAddress.toString())\n                .concat(\". The signer must initialize their account with this object first!\"))\n\n        self.tempVault <- vaultRef.withdraw(amount: amount)\n\n        // Get the string representation of the address without the 0x\n        var addressString = contractAddress.toString()\n        if addressString.length == 18 {\n            addressString = addressString.slice(from: 2, upTo: 18)\n        }\n        let typeString: String = \"A.\".concat(addressString).concat(\".\").concat(contractName).concat(\".Vault\")\n        let type = CompositeType(typeString)\n        assert(\n            type != nil,\n            message: \"Could not create a type out of the contract name and address!\"\n        )\n\n        assert(\n            self.tempVault.getType() == type!,\n            message: \"The Vault that was withdrawn to transfer is not the type that was requested!\"\n        )\n    }\n\n    execute {\n        let recipient = getAccount(to)\n        let receiverRef = recipient.capabilities.borrow<&{FungibleToken.Receiver}>(self.vaultData.receiverPath)\n            ?? panic(\"Could not borrow a Receiver reference to the FungibleToken Vault in account \"\n                .concat(to.toString()).concat(\" at path \").concat(self.vaultData.receiverPath.toString())\n                .concat(\". Make sure you are sending to an address that has \")\n                .concat(\"a FungibleToken Vault set up properly at the specified path.\"))\n\n        // Transfer tokens from the signer's stored vault to the receiver capability\n        receiverRef.deposit(from: <-self.tempVault)\n    }\n}\n","import evmCall from \"./cadence/transactions/evm/call.cdc\";\n// Transactions for main account\nimport mainAccountCreateNewWithCOA from \"./cadence/transactions/main-account/account/create_new_account_with_coa.cdc\";\nimport mainAccountSetupCOA from \"./cadence/transactions/main-account/account/setup_coa.cdc\";\nimport mainEVMTransferERC20 from \"./cadence/transactions/main-account/evm/transfer_erc20.cdc\";\nimport mainFlowTokenDynamicTransfer from \"./cadence/transactions/main-account/flow-token/dynamic_vm_transfer.cdc\";\nimport mainFTGenericTransfer from \"./cadence/transactions/main-account/ft/generic_transfer_with_address.cdc\";\n\nexport const transactions = {\n    evmCall,\n    mainAccountCreateNewWithCOA,\n    mainAccountSetupCOA,\n    mainEVMTransferERC20,\n    mainFlowTokenDynamicTransfer,\n    mainFTGenericTransfer,\n};\n","export * from \"./transfer\";\n","import { z } from \"zod\";\nimport { injectable } from \"inversify\";\nimport {\n    elizaLogger,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    type State,\n} from \"@elizaos/core\";\nimport { type ActionOptions, globalContainer, property } from \"@elizaos-plugins/plugin-di\";\nimport { formatTransationSent } from \"../helpers/formater\";\nimport { BaseFlowInjectableAction } from \"../helpers/baseAction\";\nimport { isCadenceIdentifier, isEVMAddress, isFlowAddress } from \"../helpers/checker\";\nimport { transactions } from \"../assets/transaction.defs\";\n\n/**\n * The generated content for the transfer action\n */\nexport class TransferContent {\n    @property({\n        description:\n            \"Cadence Resource Identifier or ERC20 contract address (if not native token). this field should be null if the token is native token: $FLOW or FLOW\",\n        examples: [\n            \"For Cadence resource identifier, the field should be 'A.1654653399040a61.ContractName'\",\n            \"For ERC20 contract address, the field should be '0xe6ffc15a5bde7dd33c127670ba2b9fcb82db971a'\",\n        ],\n        schema: z.string().nullable(),\n    })\n    token: string | null;\n\n    @property({\n        description: \"Amount to transfer, it should be a number or a string\",\n        examples: [\"'1000'\", \"1000\"],\n        schema: z.union([z.string(), z.number()]),\n    })\n    amount: string;\n\n    @property({\n        description:\n            \"Recipient identifier, can a wallet address like EVM address or Cadence address. It should be a string\",\n        examples: [\n            \"For Cadence address: '0x1654653399040a61'\",\n            \"For EVM address: '0x742d35Cc6634C0532925a3b844Bc454e4438f44e'\",\n        ],\n        schema: z.string(),\n    })\n    to: string;\n}\n\n/**\n * The transfer action options\n */\nconst transferOption: ActionOptions<TransferContent> = {\n    name: \"SEND_COIN\",\n    similes: [\n        \"SEND_TOKEN\",\n        \"SEND_TOKEN_ON_FLOW\",\n        \"TRANSFER_TOKEN_ON_FLOW\",\n        \"TRANSFER_TOKENS_ON_FLOW\",\n        \"TRANSFER_FLOW\",\n        \"SEND_FLOW\",\n        \"PAY_BY_FLOW\",\n    ],\n    description:\n        \"Call this action to transfer any fungible token/coin from the agent's Flow wallet to another address\",\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Send 1 FLOW to 0xa2de93114bae3e73\",\n                    action: \"SEND_COIN\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Send 1 FLOW - A.1654653399040a61.FlowToken to 0xa2de93114bae3e73\",\n                    action: \"SEND_COIN\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Send 1000 FROTH - 0xb73bf8e6a4477a952e0338e6cc00cc0ce5ad04ba to 0x000000000000000000000002e44fbfbd00395de5\",\n                    action: \"SEND_COIN\",\n                },\n            },\n        ],\n    ],\n    contentClass: TransferContent,\n    suppressInitialMessage: true,\n};\n\n/**\n * Transfer action\n *\n * @category Actions\n * @description Transfer funds from one account to another\n */\n@injectable()\nexport class TransferAction extends BaseFlowInjectableAction<TransferContent> {\n    constructor() {\n        super(transferOption);\n    }\n\n    /**\n     * Validate the transfer action\n     * @param runtime the runtime instance\n     * @param message the message content\n     * @param state the state object\n     */\n    async validate(runtime: IAgentRuntime, message: Memory, state?: State): Promise<boolean> {\n        if (await super.validate(runtime, message, state)) {\n            // TODO: Add custom validation logic here to ensure the transfer does not come from unauthorized sources\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Execute the transfer action\n     *\n     * @param content the content from processMessages\n     * @param callback the callback function to pass the result to Eliza runtime\n     * @returns the transaction response\n     */\n    async execute(\n        content: TransferContent | null,\n        _runtime: IAgentRuntime,\n        _message: Memory,\n        _state?: State,\n        callback?: HandlerCallback,\n    ) {\n        if (!content) {\n            elizaLogger.warn(\"No content generated\");\n            return;\n        }\n\n        elizaLogger.log(`Starting ${this.name} handler...`);\n\n        // Use main account of the agent\n        const walletAddress = this.walletSerivce.address;\n        const logPrefix = `Account[${walletAddress}/root]`;\n\n        // Parsed fields\n        const amount =\n            typeof content.amount === \"number\" ? content.amount : Number.parseFloat(content.amount);\n        const recipient = content.to;\n\n        try {\n            let txId: string;\n            let keyIndex: number;\n\n            // For different token types, we need to handle the token differently\n            if (!content.token) {\n                // Check if the wallet has enough balance to transfer\n                const fromAccountInfo = await this.walletSerivce.getWalletAccountInfo();\n                const totalBalance = fromAccountInfo.balance + (fromAccountInfo.coaBalance ?? 0);\n\n                // Check if the amount is valid\n                if (totalBalance < amount) {\n                    throw new Error(\"Insufficient balance to transfer\");\n                }\n\n                elizaLogger.log(`${logPrefix}\\n Sending ${amount} FLOW to ${recipient}...`);\n                // Transfer FLOW token\n                const resp = await this.walletSerivce.sendTransaction(\n                    transactions.mainFlowTokenDynamicTransfer,\n                    (arg, t) => [\n                        arg(recipient, t.String),\n                        arg(amount.toFixed(8), t.UFix64),\n                    ],\n                )\n                txId = resp.txId;\n                keyIndex = resp.index;\n            } else if (isCadenceIdentifier(content.token)) {\n                if (!isFlowAddress(recipient)) {\n                    throw new Error(\"Recipient address is not a valid Flow address\");\n                }\n\n                // Transfer Fungible Token on Cadence side\n                const [_, tokenAddr, tokenContractName] = content.token.split(\".\");\n                elizaLogger.log(\n                    `${logPrefix}\\n Sending ${amount} A.${tokenAddr}.${tokenContractName} to ${recipient}...`,\n                );\n                const resp = await this.walletSerivce.sendTransaction(\n                    transactions.mainFTGenericTransfer,\n                    (arg, t) => [\n                        arg(amount.toFixed(8), t.UFix64),\n                        arg(recipient, t.Address),\n                        arg(`0x${tokenAddr}`, t.Address),\n                        arg(tokenContractName, t.String),\n                    ],\n                )\n                txId = resp.txId;\n                keyIndex = resp.index;\n            } else if (isEVMAddress(content.token)) {\n                if (!isEVMAddress(recipient)) {\n                    throw new Error(\"Recipient address is not a valid EVM address\");\n                }\n\n                elizaLogger.log(\n                    `${logPrefix}\\n Sending ${amount} ${content.token}(EVM) to ${recipient}...`,\n                );\n\n                // Transfer ERC20 token on EVM side\n                const resp = await this.walletSerivce.sendTransaction(\n                    transactions.mainEVMTransferERC20,\n                    (arg, t) => [\n                        arg(recipient, t.String),\n                        arg(amount.toFixed(8), t.UFix64),\n                        arg(content.token, t.String),\n                    ],\n                )\n                txId = resp.txId;\n                keyIndex = resp.index;\n            }\n\n            elizaLogger.log(`${logPrefix}\\n Sent transaction: ${txId} by KeyIndex[${keyIndex}]`);\n\n            // call the callback with the transaction response\n            if (callback) {\n                const tokenName = content.token || \"FLOW\";\n                const extraMsg = `${logPrefix}\\n Successfully transferred ${content.amount} ${tokenName} to ${content.to}`;\n                callback?.({\n                    text: formatTransationSent(txId, this.walletSerivce.wallet.network, extraMsg),\n                    content: {\n                        success: true,\n                        txid: txId,\n                        token: content.token,\n                        to: content.to,\n                        amount: content.amount,\n                    },\n                });\n            }\n        } catch (e) {\n            elizaLogger.error(\"Error in sending transaction:\", e.message);\n            callback?.({\n                text: `${logPrefix}\\n Unable to process transfer request. Error: \\n ${e.message}`,\n                content: {\n                    error: e.message,\n                },\n            });\n        }\n\n        elizaLogger.log(`Finished ${this.name} handler.`);\n    }\n}\n\n// Register the transfer action\nglobalContainer.bind(TransferAction).toSelf();\n","// Export all definitions from the Flow plugin\nexport * from \"./environment\";\nexport * from \"./types\";\nexport * from \"./helpers\";\nexport * from \"./di\";\nexport * as symbols from \"./symbols\";\nexport * as queries from \"./queries\";\nexport * from \"./assets/script.defs\";\nexport * from \"./assets/transaction.defs\";\nexport * as actions from \"./actions\";\nexport * from \"./providers\";\nexport * from \"./services\";\n\n// Export the plugin\nimport type { Plugin } from \"@elizaos/core\";\nimport { flowWalletProvider, flowConnectorProvider } from \"./providers\";\n\nexport const flowPlugin: Plugin = {\n    name: \"flow\",\n    description: \"Flow Plugin for Eliza\",\n    providers: [flowWalletProvider, flowConnectorProvider],\n    actions: [],\n    evaluators: [],\n    services: [],\n};\n\nexport default flowPlugin;\n"],"mappings":"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","names":["z","FLOW_MAINNET_PUBLIC_RPC","flowEnvSchema","z","object","FLOW_ADDRESS","string","min","startsWith","FLOW_PRIVATE_KEY","FLOW_NETWORK","optional","default","FLOW_ENDPOINT_URL","validateFlowConfig","runtime","config","getSetting","process","env","parse","error","ZodError","errorMessages","errors","map","err","path","join","message","Error","isUUID","str","uuidRegex","test","isFlowAddress","address","regExp","isEVMAddress","isCadenceIdentifier","cadenceIdentifier","isScriptQueryResponse","res","ok","formatAgentWalletInfo","character","info","output","name","formatWalletBalances","formatWalletInfo","userId","accountName","undefined","formatAccountInfoPrefix","address","balance","coaAddress","coaBalance","formatWalletCreated","newAddress","formatTransationSent","txId","network","extra","baseUrl","txURL","formatFlowSpent","fromAddress","spent","agentAddr","gasFee","inject","injectable","unmanaged","composeContext","elizaLogger","BaseInjectableAction","injectable","inject","elizaLogger","Service","globalContainer","fcl","elliptic","SHA3","PureSigner","signWithKey","privateKeyHex","msg","ec","elliptic","key","keyFromPrivate","Buffer","from","sig","sign","_hashMsg","n","r","toArrayLike","s","concat","valueOf","toString","sha","SHA3","update","digest","fcl","Exception","Error","constructor","code","message","options","isGloballyInited","globallyPromise","FlowConnector","constructor","flowJSON","network","defaultRpcEndpoint","undefined","rpcEndpoint","Exception","onModuleInit","cfg","config","put","load","ensureInited","getAccount","addr","send","then","decode","sendTransaction","code","args","mainAuthz","extraAuthz","mutate","cadence","proposer","payer","authorizations","length","getTransactionStatus","transactionId","tx","onceExecuted","getChainId","onceTransactionSealed","onceSealed","getBlockHeaderObject","blockId","getBlockHeader","atBlockId","executeScript","defaultValue","queryResult","query","e","console","error","elizaLogger","NodeCache","fcl","FlowWallet","runtime","privateKeyHex","address","account","maxKeyIndex","constructor","connector","cache","NodeCache","stdTTL","signerAddr","getSetting","elizaLogger","error","Exception","privateKey","warn","startsWith","slice","network","sendTransaction","code","args","authz","buildAuthorization","executeScript","defaultValue","accountIndex","addr","sansPrefix","keyId","Number","signingFunction","signable","Promise","resolve","f_type","f_vsn","withPrefix","signature","signMessage","message","PureSigner","signWithKey","syncAccountInfo","getAccount","keys","length","set","balance","debug","keyAmount","getWalletBalance","forceRefresh","cachedBalance","get","path","injectable","v4","NodeCache","globalContainer","CacheProvider","_nodeCache","cacheKey","CACHE_EXPIRY_SEC","providerId","_fileCache","constructor","NodeCache","stdTTL","v4","getInstance","runtime","cacheManager","get","_message","_state","getCachedData","key","cachedData","fileCachedData","_readFromCache","set","setCachedData","data","ttl","_writeToCache","_getFileCacheKey","path","join","expires","Date","now","globalContainer","bind","toSelf","inRequestScope","cacheProvider","injectable","inject","elizaLogger","globalContainer","CONSTANTS","FlowJSON","Symbol","for","_createFlowConnector","runtime","flowJSON","rpcEndpoint","getSetting","network","instance","FlowConnector","onModuleInit","getFlowConnectorInstance","inputedFlowJSON","undefined","connector","networks","dependencies","ConnectorProvider","_connector","constructor","getInstance","getConnectorStatus","output","character","name","get","_message","state","CONNECTOR_PROVIDER_SESSION_FLAG","error","elizaLogger","message","FlowJSON","globalContainer","bind","toSelf","inSingletonScope","flowConnectorProvider","injectable","inject","elizaLogger","globalContainer","scripts","evmCall","evmERC20BalanceOf","evmERC20GetDecimals","evmERC20GetTotalSupply","mainGetAccountInfo","queryEvmERC20BalanceOf","executor","owner","evmContractAddress","ret","executeScript","scripts","evmERC20BalanceOf","arg","t","String","BigInt","queryEvmERC20Decimals","evmERC20GetDecimals","Number","parseInt","queryEvmERC20TotalSupply","evmERC20GetTotalSupply","queryAccountBalanceInfo","address","mainGetAccountInfo","Address","undefined","balance","parseFloat","coaAddress","coaBalance","WalletProvider","_wallet","constructor","connector","getInstance","runtime","connectorIns","FlowWallet","get","_message","state","WALLET_PROVIDER_SESSION_FLAG","getSetting","elizaLogger","error","walletProvider","info","queryAccountBalanceInfo","address","output","character","name","formatWalletBalances","message","globalContainer","bind","toSelf","inRequestScope","flowWalletProvider","flowConnectorProvider","FlowWalletService","Service","isInitialized","_runtime","_connector","_wallet","_maxKeyIndex","keysInUse","keysTrackingPayloads","constructor","connectorProvider","walletProvider","Set","Map","serviceType","initialize","runtime","getInstance","acctInfo","getAccount","address","keys","length","connector","wallet","maxKeyIndex","executeScript","code","argsFunc","defaultValue","sendTransaction","callbacks","index","acquireAndLockIndex","Error","txId","buildAuthorization","startTransactionTrackingSubstribe","error","ackAndUnlockIndex","getWalletAccountInfo","queryAccountBalanceInfo","txid","has","payload","get","unsubscribe","delete","elizaLogger","info","isFinalizedSent","unsub","tx","subscribe","res","onStatusUpdated","status","onFinalized","errorMessage","onSealed","set","i","add","globalContainer","bind","toSelf","inSingletonScope","BaseFlowInjectableAction","BaseInjectableAction","walletElizaProvider","walletSerivce","constructor","opts","validate","runtime","_message","_state","validateFlowConfig","wallet","getWalletBalance","elizaLogger","error","prepareActionContext","message","state","currentState","composeState","updateRecentMessageState","walletInfo","get","composeContext","template","handler","options","callback","res","isScriptQueryResponse","ok","log","JSON","stringify","data","errorMessage","signer","txid","address","keyIndex","fs","path","elizaLogger","globalContainer","globalContainer","bind","CONSTANTS","FlowJSON","toDynamicValue","cwd","process","pathsToTry","path","resolve","elizaLogger","info","map","p","exists","fs","existsSync","jsonObjcet","tryPath","with","type","default","error","Error","call_default","transactions","evmCall","mainAccountCreateNewWithCOA","mainAccountSetupCOA","mainEVMTransferERC20","mainFlowTokenDynamicTransfer","mainFTGenericTransfer","z","injectable","elizaLogger","globalContainer","property","TransferContent","token","amount","to","description","examples","schema","z","string","nullable","union","number","transferOption","name","similes","user","content","text","action","contentClass","suppressInitialMessage","TransferAction","BaseFlowInjectableAction","constructor","validate","runtime","message","state","execute","_runtime","_message","_state","callback","elizaLogger","warn","log","walletAddress","walletSerivce","address","logPrefix","Number","parseFloat","recipient","txId","keyIndex","fromAccountInfo","getWalletAccountInfo","totalBalance","balance","coaBalance","Error","resp","sendTransaction","transactions","mainFlowTokenDynamicTransfer","arg","t","String","toFixed","UFix64","index","isCadenceIdentifier","isFlowAddress","_","tokenAddr","tokenContractName","split","mainFTGenericTransfer","Address","isEVMAddress","mainEVMTransferERC20","tokenName","extraMsg","formatTransationSent","wallet","network","success","txid","e","error","globalContainer","bind","toSelf","flowPlugin","name","description","providers","flowWalletProvider","flowConnectorProvider","actions","evaluators","services"]}